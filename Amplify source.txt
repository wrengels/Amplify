SOAPMethod.Parameter:Sub Parameter(name as string, Assigns value as variant)  inputParams.value(name) = valueEnd SubSOAPMethod.Constructor:Sub Constructor()  initializeEnd SubSOAPMethod.ExecuteRPC:Private Function ExecuteRPC() As SOAPResult  dim response as string    // intialize connection  if connection = NIL then    connection = new httpSocket  end    // set up the post data  connection.setRequestHeader "SOAPAction",action  connection.setPostContent formatEnvelope(),"text/xml"  response = connection.post(url,timeout)    // handle error  if connection.errorCode() <> 0 then    return NIL  end    // parse the response  return parseSOAPResult(response)End FunctionSOAPMethod.ParseSOAPResult:Private Function ParseSOAPResult(resultData as string) As SOAPResult  dim sr as soapResult  dim i,j as integer  dim xnode as xmlNode    // parse soap result  sr = new soapResult  sr.document = new xmlDocument  sr.document.loadXML resultData    // extract envelope  for i = 0 to sr.document.childCount-1    xnode = sr.document.child(i)    if xnode.localName = "Envelope" then      sr.envelope = xnode      exit    end  next    // provide access to the body tag without having to go through envelope  for i = 0 to sr.envelope.childCount-1    xnode = sr.envelope.child(i)    if xnode.localName = "Body" then      sr.body = xmlElement(xnode)      exit    end  next    // check for faults  for i = 0 to sr.body.childCount-1    xnode = sr.body.child(i)    if xnode.localName = "Fault" then// fault was found      sr.error = true      for j = 0  to xnode.childCount-1// extract fault code and message        if xnode.child(j).localName = "FaultCode" then          sr.errorCode = val(xnode.child(j).firstChild.value)        end        if xnode.child(j).localName = "FaultString" then          sr.errorMessage = xnode.child(j).firstChild.value        end      next      exit    end  next      // return the result  return sr    exception err as XMLException  sr.error = true  sr.errorCode = -1  sr.errorMessage = err.message  return srEnd FunctionSOAPMethod.Constructor:Sub Constructor(WSDLurl as string)  initialize  loadWSDLFromURL WSDLurlEnd SubSOAPMethod.LoadWSDLFromURL:Sub LoadWSDLFromURL(url as string)  dim pageGrab as _soapSocket  dim response as string    // use the user defined socket if one exists  if connection = NIL then    pageGrab = new httpSocket  else    pageGrab = me.connection  end    // get the wsdl  response = pageGrab.get(url,timeout)  if pageGrab.errorCode <> 0 then    raise getSOAPException("WSDL could not be loaded from URL")  end    // parse the wsdl  wsdl = new xmlDocument  wsdl.loadXml responseEnd SubSOAPMethod.InvokeMethod:Private Function InvokeMethod(name as string, paramIsArray as boolean) As string  dim sr as soapResult  dim resultNode as xmlNode    // parse wsdl if found  if wsdl <> NIL then    parseWSDL name,paramIsArray  else// call function with no wsdl    methodName = name  end    // execute the function  sr = executeRPC()  if sr = NIL then    return ""  end    // find the result node  resultNode = sr.body.firstChild.firstChild.firstChild  if resultNode = NIL then    resultNode = sr.body.firstChild.firstChild    return resultNode.value  end    // return the result  if resultNode.type = 3 then    return resultNode.value  else    return resultNode.toString()  end ifEnd FunctionSOAPMethod.Operator_Lookup:Function Operator_Lookup(funcName as string, ParamArray params as variant) As string  dim i as integer    if ubound(params) = -1 then// there are no parameters    if wsdl <> NIL then// clear parameters if there is a wsdl defined      inputParams.clear    end  else// parameters exist    inputParams.clear// clear stale parameters    for i = 0 to ubound(params)// assign new parameters      inputParams.value(str(i)) = params(i)    next  end    return invokeMethod(funcName,true)End FunctionSOAPMethod.wsdlFindParamNodesParent:Private Function wsdlFindParamNodesParent(funcName as string) As xmlNode  dim rlist as xmlNodeList  dim inputMessage as string  dim inputmessageNode, sequenceNode as xmlNode    // first find the port input name  rlist = wsdlQuery("definitions/portType/operation[@name='" + funcName + "']/input")  inputMessage = xmlElement(rlist.Item(0)).GetAttribute("message")  inputMessage = nthField(inputMessage, ":", 2)    rlist = wsdlQuery("definitions/message[@name='" + inputMessage + "']")  inputMessageNode = rlist.Item(0)    if inputMessageNode.childCount = 0 then    return NIL  end    // some wsdl services will go ahead and have our param details here  if inputMessageNode.childCount >= 1 AND xmlElement(inputMessageNode.firstChild).getAttribute("type") <> "" then    return inputMessageNode  end    // if there is only one <part> tag and it has an "element" attribute, then we have to find our params  // in the <types> node  if inputMessageNode.childCount = 1 AND xmlElement(inputMessageNode.firstChild).getAttribute("element") <> "" then    rlist = wsdlQuery("definitions/types/schema/element[@name='" + funcName + "']/complexType/sequence")    sequenceNode = rlist.Item(0)    return sequenceNode  end    return NILEnd FunctionSOAPMethod.wsdlFunctionExists:Private Function wsdlFunctionExists(funcName as string) As string  dim rlist as xmlNodeList  dim i as integer    rlist = wsdlQuery("definitions/binding/operation[@name]")  for i = 0 to rlist.length-1    if xmlElement(rlist.item(i)).getAttribute("name") = funcName then      return xmlElement(rlist.item(i)).getAttribute("name")    end  next    return ""End FunctionSOAPMethod.wsdlGetAction:Private Function wsdlGetAction(funcName as string) As string  dim rlist as xmlNodeList  dim action as string    rlist = wsdlQuery("definitions/binding/operation[@name='" + funcName + "']/operation")  action = xmlElement(rlist.item(0)).getAttribute("soapAction")    return actionEnd FunctionSOAPMethod.wsdlGetAddress:Private Function wsdlGetAddress() As string  dim rlist as xmlNodeList  dim tmpNode as xmlNode  dim address as string    // lets get the real url of the service  rlist = wsdlQuery("definitions/service/port/address")  address = xmlElement(rlist.Item(0)).getAttribute("location")    return addressEnd FunctionSOAPMethod.wsdlGetMethodNS:Private Function wsdlGetMethodNS(funcName as string) As string  dim rlist as xmlNodeList  dim ns as string    rlist = wsdlQuery("definitions/binding/operation[@name='" + funcName + "']/input/body")  ns = xmlElement(rlist.item(0)).getAttribute("namespace")    if ns = "" then    ns = wsdl.documentElement.getAttribute("targetNamespace")  end    return nsEnd FunctionSOAPMethod.Initialize:Private Sub Initialize()  inputParams = new dictionary    namespaces = new dictionary  namespaces.value("SOAP") = "http://schemas.xmlsoap.org/soap/envelope/"  namespaces.value("xsd") = "http://www.w3.org/2001/XMLSchema"  namespaces.value("xsi") = "http://www.w3.org/2001/XMLSchema-instance"  namespaces.value("ENC") = "http://schemas.xmlsoap.org/soap/encoding/"  namespaces.value("si") = "http://soapinterop.org/xsd"    paramTypes = new dictionary  paramTypes.value("0") = ""// nil  paramTypes.value("2") = "int"// integer  paramTypes.value("5") = "double"// double  paramTypes.value("7") = "string"// date  paramTypes.value("8") = "string"// string  paramTypes.value("9") = ""// object  paramTypes.value("11") = "boolean"// boolean  paramTypes.value("16") = "string"// colorEnd SubSOAPMethod.Invoke:Function Invoke(name as string) As SOAPResult  // record the method name  methodName = name    // if a wsdl exists then use its definition of the method  if wsdl <> NIL then    parseWSDL name,false  end    // return result  return executeRPC()End FunctionSOAPMethod.ParseWSDL:Private Sub ParseWSDL(name as string, paramIsArray as boolean)  dim paramParent as xmlNode  dim i as integer    // set method name  methodName = wsdlFunctionExists(name)    // does the function exist  if methodName = "" then    raise getSOAPException("Method name does not exist in WSDL")  end    // extract method properties from wsdl  url = wsdlGetAddress()  action = wsdlGetAction(methodName)  methodNamespace = wsdlGetMethodNS(methodName)  paramParent = wsdlFindParamNodesParent(methodName)    // validate parameter count  if paramParent = NIL then// no parameters found    if inputParams.count > 0 then// parameters were passed in      raise getSOAPException("Incorrect parameters")    end    return// no parameters so we are done  end  if paramParent.childCount <> inputParams.count then// compare input params with needed params    raise getSOAPException("Incorrect parameters")  end    // set up parameters  for i = 0 to paramParent.childCount-1    if paramIsArray = true then// change array index to name      inputParams.value(xmlElement(paramParent.child(i)).getAttribute("name")) = inputParams.value(str(i))      inputParams.remove str(i)    else// verify parameter names      if inputParams.hasKey(xmlElement(paramParent.child(i)).getAttribute("name")) = false then        raise getSOAPException("Incorrect parameters")      end    end  nextEnd SubSOAPMethod.GetSOAPException:Private Function GetSOAPException(message as string) As SOAPException  dim err as SOAPException    err = new SOAPException  err.message = message    return errEnd FunctionSOAPMethod.FormatEnvelope:Private Function FormatEnvelope() As string  dim env as xmlDocument  dim xbody,xdef as xmlNode  dim i as integer    // create document  env = new xmlDocument    // setup envelope and namespaces  env.appendChild env.createElement(namespaces.value("SOAP"),"SOAP:Envelope")  for i = 0 to namespaces.count-1    env.documentElement.setAttribute "xmlns:"+namespaces.key(i),namespaces.value(namespaces.key(i))  next    // create body  xbody = env.createElement(namespaces.value("SOAP"),"SOAP:Body")  env.documentElement.appendChild xbody    // create method  xdef = env.createElement(methodNameSpace,methodName)  xbody.appendChild xdef    // set parameters  for i = 0 to inputParams.count-1    xdef.appendChild getParameterNode(env,i)  next    // return envelope string  return env.toString()End FunctionSOAPMethod.GetParameterNode:Private Function GetParameterNode(env as xmlDocument, idx as integer) As xmlNode  dim xnode as xmlElement  dim pname,ptype,pval as string    // extract parameter name and type  pname = inputParams.key(idx)  ptype = "xsd:"+ paramTypes.value(str(inputParams.value(pname).type))    // format parameter types  select case inputParams.value(pname).type  case 11// boolean    if inputParams.value(pname).booleanValue = true then      pval = "1"    else      pval = "0"    end      case 9// object    if inputParams.value(pname).objectValue isa XMLNode then      xnode = xmlElement(inputParams.value(pname).objectValue)    end      else    pval = inputParams.value(pname).stringValue  end    // create node from parameter data if parameter value wasn't already a node  if xnode = NIL then    xnode = env.createElement(pname)    xnode.setAttribute namespaces.value("xsi"),"xsi:type",ptype    xnode.appendChild env.createTextNode(pval)  end    // return parameter node  return xnodeEnd FunctionSOAPMethod.UseSocket:Sub UseSocket(SOAPsocket as _SOAPSocket)  me.connection = soapSocketEnd SubSOAPMethod.ClearParameters:Sub ClearParameters()  inputParams.clearEnd SubSOAPMethod.wsdlQuery:Private Function wsdlQuery(query as string) As xmlNodeList  dim i,x as integer  dim output,qstr,tmp,attr as string    // Format the XQL query to support namespaces.  We these queries after the fact  // in order to keep them more human readable in code for debugging.  for i = 1 to countFields(query,"/")    tmp = nthField(query,"/",i)        x = instr(tmp,"[")    if x > 0 then      attr = mid(tmp,x)      tmp = nthField(tmp,"[",1)    end        qstr = "*[local-name()='"+ tmp +"']"    if x > 0 then      qstr = qstr + attr    end        output = output +"/"+ qstr  next  output = mid(output,2)    // run the query  return wsdl.xql(output)End FunctionSeqWindow.saveFile:Sub saveFile(fileName As String, DisplaySaveDialog As Boolean)  Dim f as FolderItem  if Document = Nil or DisplaySaveDialog then    f = GetSaveFolderItem("text/Amplify", fileName)    if f <> Nil then // the user clicked Save      'MsgBox "'" + f.name + "'     the type is '" + f.Type + "'    and creator is '" + f.MacCreator + "'   and TYPE is: '" + f.MacType + "'"      f.MacCreator="Ampl"      'MsgBox "'" + f.name + "'     the type is '" + f.Type + "'    and creator is '" + f.MacCreator + "'   and TYPE is: '" + f.MacType + "'"      Title = f.Name      Document = f    end if  end if  if Not DisplaySaveDialog then // it's Save not Save As    if Document <> Nil then      Document.SaveStyledEditField SeqT      TextHasChanged=false    end if  elseif displaySaveDialog then //user chose SaveAs or it's a new doc    if Document<>Nil and f <> Nil then      Document.SaveStyledEditField SeqT      TexthasChanged = False    end if  end if  'MsgBox "'" + f.name + "'     the type is '" + f.Type + "'    and creator is '" + f.MacCreator + "'   and TYPE is: '" + f.MacType + "'"  End SubSeqWindow.adjustlineNumbers:Sub adjustlineNumbers()  dim sp, linelength, lastLine, firstSeqLine as integer  dim t as string  dim i, numlines as integer  linelength = SeqT.charPosAtLineNum(1) - SeqT.CharPosAtLineNum(0)  firstSeqLine = SeqT.LineNumAtCharPos(seqStart)  lastLine = SeqT.LineNumAtCharPos(len(SeqT.Text))  t=""  for i = 0 to lastLine    if i < firstSeqLine then      t=t+"-"+EndOfLine    else      t = t + str(SeqT.CharPosAtLineNum(i) - Seqstart + 1) + EndOfLine    end if  next  lineNumbers.Text = t  fixScrollPositionEnd SubSeqWindow.fixScrollPosition:Sub fixScrollPosition()  dim sp as integer  sp = SeqT.ScrollPosition  SeqT.ScrollPosition = sp  lineNumbers.ScrollPosition=sp  sequenceScroll.Value=sp  sequenceScroll.Maximum=SeqT.LineNumAtCharPos(Len(SeqT.Text))  SequenceScroll.Minimum=0End SubSeqWindow.doFormat:Sub doFormat()  dim tempStart, tempLen, seqlen,targlen, i, badlength, okaypos as Integer  dim styData, okbases, c, targe as String  dim bad As  Boolean  dim run As StyleRun  dim nruns, runStart As Integer  dim st As StyledText  dim tseq As MemoryBlock      if not Formatted then    SeqT.Visible=False    seqStart=instrB(seqT.Text, endHeader)        if seqStart = 0 then  // there is no header      seqStart = 1    else   // header exists      seqStart = seqStart  + len(endHeader)    end if        tempStart = SeqT.SelStart    tempLen = SeqT.SelLength    SeqT.SelStart=0    SeqT.SelLength=Len(SeqT.Text)    SeqT.SelTextFont =SeqT.textFont    SeqT.SeltextSize=SeqT.textSize        okbases = "GATCNgatcn"    seqlen = Len(SeqT.Text)    targlen = seqlen - seqStart + 1    bad=true    WaitYoass.message.text = "Formatting Sequence"    WaitYoass.progress.value = 0    WaitYoass.show    badlength =0    ATpairs = 0    GCpairs = 0    Npairs = 0        if seqStart > 1 then // there is a header and we should change it's color      SeqT.SelStart = 0      SeqT.SelLength = SeqStart - 1      SeqT.SelTextColor = headerColor    end if        'targe = mid(SeqT.Text, seqStart, targlen)    'tseq = NewMemoryBlock(targlen+1)    'tseq.CString(0) = targe        st = new StyledText    nruns = seqT.StyledText.StyleRunCount    tseq = NewMemoryBlock(1)    for i = 0 to nruns-1      run = seqT.StyledText.StyleRun(i)      runStart = seqT.StyledText.StyleRunRange(i).StartPos      if runStart+1 >= seqStart then // we're not in the header        tseq.size = len(run.Text)+1        tseq.CString(0) = run.Text        #If TargetMacOS          cDNAfix(tseq, ATpairs, GCpairs, Npairs, badlength)        #Else          DNAfix(tseq, ATpairs, GCpairs, Npairs, badlength) // C++ routine maybe a bit faster        #Endif        badlength = badlength - 1 // because each Cstring adds a zero character        run.Text = tseq.CString(0)              end if      st.AppendStyleRun run      WaitYoass.progress.value = 100 * i/nruns      WaitYoass.refresh    next i    WaitYoass.remark.Text = "There were " + str(badlength) + " extra characters"    WaitYoass.Refresh        if badlength > 0 then seqT.StyledText = st // This is the statement that takes a long time!        WaitYoass.progress.value = 100    waitYoass.refresh    WaitYoass.remark.Text = ""    WaitYoass.hide    SeqT.SelStart = tempStart    SeqT.SelLength = tempLen        SeqT.Visible=True    adjustlineNumbers    Formatted = true    seqLength = len(SeqT.text) - seqStart + 1    SeqT.SetFocus    SeqT.visible = true  end ifEnd SubSeqWindow.InvertSelection:Sub InvertSelection()  dim i, blockstart, blockend, blockLength, oristart, orilength, oriend as integer  dim c, block as string  dim sBold, sItalic, sUnderline As boolean  dim sColor As color    orilength = SeqT.SelLength  oriStart = SeqT.SelStart  oriend = oristart + orilength-1  if oriLength > 0 then    SeqT.visible = false    progressBar1.visible = true    progressBar1.value = 1        blockStart = oristart    do      Seqt.Selstart = blockStart      Seqt.SelLength = 1      sBold = Seqt.Selbold      sItalic = Seqt.SelItalic      sUnderline = Seqt.SelUnderline      sColor = seqt.SelTextcolor            blockEnd = blockStart-1      do        if blockEnd < oriEnd then          blockEnd = blockEnd+1        end if        Seqt.SelStart = blockEnd+1        Seqt.SelLength = 1      loop until (sBold <> Seqt.Selbold) or (sItalic <> Seqt.SelItalic) or (sUnderline <> Seqt.SelUnderline) or (sColor <> seqt.SelTextcolor) or (blockEnd >= oriEnd)      //We have a block of identical format      blockLength = blockEnd - blockStart +1      block = ""      for i = blockStart to BlockEnd        c = mid(SeqT.Text, i+1, 1)        c=mid(comp, InstrB(bases, c), 1)        block = c + block      next      SeqT.Selstart = oriend + 1      SeqT.selLength = 0      SeqT.selText = block            SeqT.Selstart = oriend + 1      Seqt.SelLength = blockLength            SeqT.selBold = sbold      seqT.selItalic = sItalic      seqT.selUnderline = sUnderline      seqT.selTextColor = scolor      blockStart = blockEnd + 1      progressBar1.value = 100 * (blockStart - oriStart)/oriLength    loop until blockend >= oriend        SeqT.SelStart=oristart    SeqT.SelLength=oriLength    SeqT.SelText = ""    SeqT.SelStart=oristart    SeqT.SelLength=oriLength    SeqT.Setfocus            SeqT.SelStart = oristart    SeqT.SelLength = oriLength    SeqT.visible = true    progressBar1.visible = false  end if  End SubSeqWindow.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  dim i, n as integer  Super.Window()  n = 0  if useWindowPosPrefs then     for i = 0 to windowCount-1      if window(i) isa SeqWindow then n = n+1    next    if n > 1 then // offset multiple amp windows      seqpoz.lft = seqpoz.lft + 10      seqpoz.tp = seqpoz.tp + 10    end if    seqpoz.setvals self  end ifEnd SubSeqWindow.formatSeq:Sub formatSeq()  dim tempStart, tempLen, seqlen, i,j, badlength, runs as Integer  dim s As styledText  dim r As styleRun  dim rr As range  dim m As memoryBlock  dim styData, okbases, c as String  dim bad As  Boolean  if not Formatted then    SeqT.Visible=False    seqStart=instrB(seqT.Text, endHeader)    if seqStart = 0 then  // there is no header      seqStart = 1    else   // header exists      seqStart = seqStart  + len(endHeader)    end if    tempStart = SeqT.SelStart    tempLen = SeqT.SelLength        okbases = "GATCNgatcn"    seqlen = Len(SeqT.Text)    bad=true    WaitYoass.message.text = "Formatting Sequence"    WaitYoass.progress.value = 0    WaitYoass.show    badlength =0        s = seqT.styledText    runs = s.styleRunCount    m = newMemoryBlock(10)    for i = 0 to runs-1      r = s.styleRun(i)      rr = s.styleRunRange(i)      m.size = len(r.text)      m.Cstring(0) = r.text      for j = 1 to len(r.text)        c = mid(r.Text, j, 1)      next j      if instrB(okbases, c) = 0 then   // a bad character        badlength=badlength+1        bad=true      elseif bad then // the last okay character before a run of bad ones        bad = false        SeqT.SelStart=i        SeqT.SelLength=badlength        SeqT.SelText = ""        badlength=0      end if      if i mod 512 = 0 then         WaitYoass.progress.value = 100 * (seqlen-i)/seqlen        WaitYoass.refresh      end if    next    WaitYoass.progress.value = 100    waitYoass.refresh    if bad then  // we ended on a bad character      SeqT.SelStart=seqStart-1      SeqT.SelLength=badlength      SeqT.SelText = ""    end if        if seqStart > 1 then // there is a header and we should change it's color      SeqT.SelStart = 0      SeqT.SelLength = SeqStart - 1      SeqT.SelTextColor = headerColor    end if    WaitYoass.hide    SeqT.SelStart = tempStart    SeqT.SelLength = tempLen        SeqT.Visible=True    adjustlineNumbers    Formatted = true    SeqT.SetFocus  end ifEnd SubSeqWindow.closeAmpWindows:Protected Sub closeAmpWindows()  dim i, n As integer  n = ubound(Amplifications)  for i = 0 to n    Amplifications(i).close  next  searchw = nilEnd SubSeqWindow.DNAfix:Protected Sub DNAfix(b As memoryBlock, byRef AT As integer, byRef GC As integer, byRef NN as integer, byRef bad As integer)  dim i,n, del As integer  n = b.Size  del = 0  for i = 0 to n-1    select case b.Byte(i)    case 65, 84, 97, 116      AT = AT + 1      b.Byte(i-del) = b.Byte(i)    case 67, 71, 99, 103      GC = GC + 1      b.Byte(i-del) = b.Byte(i)    case 78, 110      NN = NN + 1      b.Byte(i-del) = b.Byte(i)    else      bad = bad + 1      del = del + 1    end Select  next  b.Byte(n-del) = 0    End SubSeqWindow.Resized:Sub Resized()  adjustlineNumbersEnd SubSeqWindow.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  adjustlineNumbersEnd FunctionSeqWindow.CancelClose:Function CancelClose(appQuitting as Boolean) As Boolean  if not me.textHasChanged then     closeAmpWindows    return false  else    saveChanges.filename.text="Save changes to '"+me.Title +"' before closing?"    saveChanges.ShowModal    select case saveChanges.buttonPressed    case "dontSave"      closeAmpWindows      return false    case "cancel"      return true    case "save"      self.saveFile title, false    end select    saveChanges.close  end if  End FunctionSeqWindow.EnableMenuItems:Sub EnableMenuItems()  dim i, lastmono as integer  SelectAll.Enable  formatFont.Enable  editFind.Enable  editFind.text = "Find Pattern ..."  if searchw <> nil then editFindNext.Enable    for i = 0 to ubound(monofonts)    fontz(i).Enable    fontz(i).Checked = fontz(i).text = seqT.TextFont  next  EditInvertSelection.enable  formatSize.Enable  s9.Enable  s9.Checked = seqT.TextSize = 9  s10.Enable  s10.Checked = seqT.TextSize = 10  s12.Enable  s12.Checked = seqT.TextSize = 12  s14.Enable  s14.Checked = seqT.TextSize = 14  s18.Enable  s18.Checked = seqT.TextSize = 18  s24.enable  s24.Checked = seqT.TextSize = 24  formatPlain.Enable  formatBold.Enable  formatUnderline.Enable  formatItalic.Enable  formatColor.Enable  cBlack.Enable  cRed.Enable  cGreen.Enable  cBlue.Enable  cOrange.Enable  cDarkBlue.Enable  cOther.Enable  formatPlain.Checked = false  formatBold.Checked = false  formatitalic.Checked = false  formatUnderline.Checked = false    if TextHasChanged  then    FileSave.Enable  end if  FileSaveAs.Enable  SeqFormat.Enable  SeqInfo.Enable  if seqT.SelLength > 0 then    SeqSetHeader.Enabled = false  else    SeqSetHeader.Enable  end ifEnd SubSeqWindow.lineNumbers.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  adjustlineNumbersEnd FunctionSeqWindow.lineNumbers.Open:Sub Open()  adjustlineNumbersEnd SubSeqWindow.SequenceScroll.ValueChanged:Sub ValueChanged()  dim point as integer  point = me.value  SeqT.ScrollPosition=point  LineNumbers.ScrollPosition= pointEnd SubSeqWindow.Boldbutton.Action:Sub Action()  SeqT.ToggleSelectionBoldEnd SubSeqWindow.ItalicsButton.Action:Sub Action()  SeqT.ToggleSelectionItalicEnd SubSeqWindow.UnderlineButton.Action:Sub Action()  SeqT.ToggleSelectionUnderlineEnd SubSeqWindow.formatSequence.Action:Sub Action()  doFormat  //formatSeqEnd SubSeqWindow.colormenu.Open:Sub Open()  me.addrow "Black"  me.addrow "Red"  me.addrow "Green"  me.addrow "Blue"  me.addrow "Orange"  me.addrow "Dark Blue"  me.addrow "Other ..."End SubSeqWindow.colormenu.Action:Sub Action()  dim c as color  dim pikedone As boolean  c=rgb(255,255,255) //default color  pikedone = true  select case me.MenuValue  case 0    c=rgb(0,0,0) //black  case 1    c=rgb(255,0,0) //red  case 2    c=rgb(0, 128, 0) //green  case 3    c=rgb(0,0,255) //blue  case 4    c=rgb(200,64,0) //orange  case 5    c=rgb(0,0,128) // dark blue  case 6    pikedone = Selectcolor(c, "Text Color")   end select  if pikedone then    SeqT.selTextColor=c    colorshow.Graphics.foreColor=c    colorshow.Refresh  end ifEnd SubSeqWindow.colorshow.Paint:Sub Paint(g As Graphics)  me.Graphics.FillRect(1,1,me.Graphics.Width-2,me.Graphics.Height-2)End SubSeqWindow.invertButton.Action:Sub Action()  dim s As styledText  dim run, runa, runb As styleRun  dim ra As range  dim t1, t2, t3 As string  dim i, s1,s2, sellen, u, ulen, firstrun As integer  s1 = seqT.selStart  sellen = seqT.selLength  if sellen > 0 then    s2 = s1 + sellen    s = seqT.styledText    firstrun = -1    for i = 0 to s.styleRunCount-1      run = s.styleRun(i)      ra = s.styleRunRange(i)      if ra.startPos <= s2 then         if ra.endPos >= s1 then           t1 = left(run.text, s1 - ra.startPos)          t3 = right(run.text, ra.endPos - s2)          u = max(1, s1 - ra.startPos+1)          ulen = min(len(run.text), sellen, s2-ra.startPos, ra.endPos - s1)          if ulen > 0 then            if firstrun < 0 then firstrun = i            t2 = mid(run.text, u, ulen)            t2 = antipar(t2)            s.removeStyleRun(i)            if t1 > "" then              run.text = t1              s.insertStyleRun(run, firstrun)              firstrun = firstrun + 1              i = i + 1            end if            run.text = t2            s.insertStyleRun(run,firstrun)            if t3 > "" then               run.text = t3              s.insertStyleRun(run, i+1)              exit            end if          end if        end if      end if    next    seqT.selStart = s1    seqT.selLength = sellen    SeqT.Setfocus    SeqT.visible = true  end ifEnd SubSeqWindow.SeqT.Open:Sub Open()  dim f as string  if monofonts.indexOf (preferredFont) > -1 then    f = preferredFont  elseif monofonts.indexOf( "Monaco") > -1 then     f = "Monaco"  elseif monofonts.indexOf("QuickType Mono") > -1 then     f = "QuickType Mono"  elseif monofonts.indexOf("Courrier New") > -1 then    f = "Courrier New"  else     f = monofonts(0)  end if  me.TextFont = f  self.lineNumbers.TextFont = f  self.showEnd SubSeqWindow.SeqT.SelChange:Sub SelChange()  dim firstbase, lastbase as Integer  if SeqT.Visible then    fixScrollPosition        if me.selLength > 0 then      firstbase=me.SelStart-seqStart +2      lastbase=me.SelLength + me.SelStart - seqStart + 1      info.Text="Selection: " + str(firstbase) + "-" + str(lastbase)      info.text = info.Text + " = " + str(lastbase-firstbase + 1) + " bp"    else      info.Text = "Position: " + str(me.selStart - seqStart + 2)    end if    //update style buttons    If Me.Selbold <> BoldButton.Value then      BoldButton.Value=Me.Selbold    End if    If Me.Selitalic <> ItalicsButton.Value then      ItalicsButton.Value=Me.Selitalic    End if    If Me.Selunderline <> UnderlineButton.Value then      UnderlineButton.Value=Me.Selunderline    End if  end ifEnd SubSeqWindow.SeqT.TextChange:Sub TextChange()  TextHasChanged=True  Formatted = FalseEnd SubSeqWindow.caseMenu.Open:Sub Open()  me.addRow "UPPER CASE"  me.addRow "lower case"End SubSeqWindow.caseMenu.Action:Sub Action()  dim s As styledText  dim run As styleRun  dim ra As range  dim t1, t2, t3 As string  dim i, s1,s2, sellen, u, ulen As integer  s1 = seqT.selStart  sellen = seqT.selLength  if sellen > 0 then    s2 = s1 + sellen    s = seqT.styledText    for i = 0 to s.styleRunCount-1      run = s.styleRun(i)      ra = s.styleRunRange(i)      if ra.startPos <= s2 then         if ra.endPos >= s1 then           t1 = left(run.text, s1 - ra.startPos)          t3 = right(run.text, ra.endPos - s2)          u = max(1, s1 - ra.startPos+1)          ulen = min(len(run.text), sellen, s2-ra.startPos, ra.endPos - s1)          t2 = mid(run.text, u, ulen)          select case me.menuValue          case 0            t2 = Uppercase(t2)          case 1            t2 = Lowercase(t2)          end select          run.text = t1 + t2 + t3          s.removeStyleRun(i)          s.insertStyleRun(run,i)        end if      end if    next    seqT.selStart = s1    seqT.selLength = sellen    SeqT.Setfocus    SeqT.visible = true  end ifEnd SubSeqWindow.PlainButton.Action:Sub Action()  SeqT.SelBold = false  seqt.SelItalic = false  seqt.SelUnderline = falseEnd SubSeqWindow.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubSeqWindow.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubSeqWindow.Canvas1.Open:Sub Open()  me.MouseCursor = fingerEnd SubSeqWindow.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display TargetWindowHelpEnd FunctionApp.InitGlobals:Sub InitGlobals()    if primerpoz <> nil then return // because intiGlobals has already run  primerpoz = new windowpoz  infopoz = new windowpoz  seqpoz = new windowpoz  amppoz = new windowpoz    prefsWindow.acquireDefaults  prefsWindow.close  doMonoFonts  'MsgBox "Did monofonts okay"    thePrimerWindow = new primerWindow    MsgBox "Got past primer window creation!"      theInfoWindow = new infoWindow  theInfoWindow.hide  thePrimerFindWindow = new findwindow    quitting = false      MsgBox "Can't get here!"        readTestFiles    MsgBox "read test files"    End SubApp.readTestFiles:Sub readTestFiles()  'temporary items for testing  dim fp, fs As folderItem  if defaultPrimerFile <> "" then    fp = getfolderItem(defaultPrimerFile)    if fp <> nil and fp.exists then      thePrimerWindow.openPrimerFile(fp)    end if  end if  if defaultPrimerFile <> "" then    fs = getfolderitem(defaultTargetFile)    if fs <> nil and fs.exists then      OpenDocument(fs)    end if  end ifEnd SubApp.doMonoFonts:Protected Sub doMonoFonts()  dim i As integer  dim g As graphics  dim p As picture  dim ii, mm As string  dim m As menuItem  p = newPicture(100,100,4)  g = p.graphics  ii = "iiiiiiii"  mm = "mmmmmmmm"  for i = 0 to fontCount-1    g.textFont = font(i)    if g.stringWidth(ii) = g.stringWidth(mm) then      if instr(font(i), "Ornaments") = 0 and instr(font(i), "Zeal") = 0 and instr(font(i), "osaka") = 0 then        if instr(font(i), "VT") = 0 and instr(font(i), "#") = 0 and instr(font(i), "OCR") = 0 then          monofonts().append font(i)          if ubound(monofonts) = 0 then            fontz(0).text = font(i)          else            m = New fontz            m.text = font(i)          end if        end if      end if    end if  nextEnd SubApp.Open:Sub Open()  if targetwin32 then    filequit.text = "E&xit"    filequit.commandKey = ""  else    badhyphen.close  end    aboutWindow.splashTimer.mode = 1  AboutWindow.splashTimer.Period = 500  aboutWindow.showModal   initGlobals  End SubApp.OpenDocument:Sub OpenDocument(item As FolderItem)  dim w as SeqWindow  dim thename as string  dim typ As string  thename = item.Name  if item <> nil then // something was opened    typ = item.Type    if thePrimerWindow = nil then initGlobals // it means it opened from desktop    if mid(thename, Len(thename)-3, 4) = ".pri" then // it's a primer list      theprimerwindow.openPrimerFile(item)    else      w=New SeqWindow      item.openStyledEditfield w.SeqT      w.Document = item      w.Title = item.Name      w.textHasChanged=false      theSeqWindow = w    end if  end ifEnd SubApp.EnableMenuItems:Sub EnableMenuItems()  'dim i, wc As integer  'dim wm As wMenuItem  'dim w As window  'dim mi As menuItem  FileNew.Enable  FileOpen.Enable  EditPreferences.Enable  About.Enable  PCRamplify.enable  SettingsLoadDefault.Enable  SettingsLoadFactory.Enable  SettingsLoadFile.Enable  SettingsSaveDefault.Enable  SettingsSaveFile.Enable  SettingsSettings.Enable  FileSettings.Enable  End SubsaveChanges.Canvas1.Paint:Sub Paint(g As Graphics)  g.drawCautionIcon 0, 0End SubsaveChanges.dontSave.Action:Sub Action()  buttonPressed="dontSave"  HideEnd SubsaveChanges.cancel.Action:Sub Action()  buttonPressed="cancel"  HideEnd SubsaveChanges.save.Action:Sub Action()  buttonPressed="save"  HideEnd Subglobals.topAmpWindow:Function topAmpWindow() As AmpWindow  dim w As AmpWindow  dim i As integer  if windowCount > 0 then    for i = 0 to windowCount-1      if window(i) isa AmpWindow then        w = AmpWindow(window(i))        exit      end if    next  end if  return wEnd Functionglobals.topSeqWindow:Function topSeqWindow() As SeqWindow  dim w As SeqWindow  dim i As integer  if windowCount > 0 then    for i = 0 to windowCount-1      if window(i) isa SeqWindow then        w = SeqWindow(window(i))        exit      end if    next  end if  return wEnd Functionglobals.putline:Sub putline(s As string)  theInfoWindow.infoField.text = theInfoWindow.infoField.text + EndOfLine + s  theInfoWindow.infoField.ScrollPosition = 999999  theInfoWindow.refreshEnd Subglobals.antipar:Function antipar(s As string) As string  dim a,c As string  dim i As integer  c = ""  for i = 1 to len(s)    c = mid(s, i, 1)    c=mid(comp, InstrB(bases, c), 1)    a = c + a  next  return aEnd Functionglobals.checkDimer:Sub checkDimer(p1 As primer, p2 As primer, ByRef olap As integer, ByRef quality As Double)  dim s1, s2 As string  dim a1(500), a2(500) As integer  dim i,j,n1, n2, nbiggus As integer  dim index1, index2 As integer  dim q As double    olap = 0  quality = -500  if len(p1.seq) <= len(p2.seq) then    s1 = p1.seq    s2 = p2.seq  else    s1 = p2.seq    s2 = p1.seq  end if  n1 = len(s1)  n2 = len(s2)  nbiggus = max(n1,n2) // just for Markus Winter's huge primers  if nbiggus > 500 then    Redim a1(nbiggus)    Redim a2(nbiggus)  end if   for i = 1 to n1    a1(i) = instrB(dbases, mid(s1,i,1))-1// dimerScores is 0-based  next  for i = 1 to n2    a2(i) = instrB(dbases, mid(s2,i,1))-1  next  for i = 1 to n2    q = 0    for j = 1 to min(i,n1)      index1 =a1(n1-j+1)       index2 = a2(n2-i+j)      q = q + dimerScores(index1, index2)    next j    if q > quality then      quality = q      olap = i    end if  next iEnd Subglobals.updateWindoze:Sub updateWindoze()  dim i , ub As integer  dim w As Window    ub = ubound(windoze)  for i = 0 to ub    windoze.remove 0  next  windoze.append theInfoWindow  windoze.append thePrimerWindow  if windowCount > 0 then    for i = 0 to WindowCount-1      w = window(i)      if w = nil then MsgBox "Oops, got a null window here boss!"            if windoze.indexOf(w) = -1 and w.visible then        windoze.append w      end if    next  end if // windowCount  i = iEnd SubAboutWindow.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  Super.Window()  VersionInfo.text = versionStringEnd SubAboutWindow.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  self.closeEnd FunctionAboutWindow.splashTimer.Action:Sub Action()  self.closeEnd SubAboutWindow.StaticText1.MouseExit:Sub MouseExit()  MouseCursor = ArrowCursorEnd SubAboutWindow.StaticText1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  ShowURL me.textEnd FunctionAboutWindow.StaticText1.MouseEnter:Sub MouseEnter()  MouseCursor = fingerEnd SubAboutWindow.StaticText4.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  LegalWindow.show  self.closeEnd FunctionAboutWindow.StaticText4.Open:Sub Open()  me.mouseCursor = fingerEnd SubAboutWindow.LicenseButton.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  LicenseWindow.show  self.closeEnd FunctionAboutWindow.LicenseButton.Open:Sub Open()  me.MouseCursor = fingerEnd Subfindwindow.EnableMenuItems:Sub EnableMenuItems()  SelectAll.EnableEnd Subfindwindow.cancelButton.Action:Sub Action()  buttonPressed = "Cancel"  HideEnd Subfindwindow.findButton.Action:Sub Action()  buttonPressed="Find"  searchString = searchBox.Text  sensitive = casesensitive.Value  HideEnd SubprimerWindow.nextline:Function nextline(s as textInputStream) As string  dim c as string  c = ""  if s.EOF then     return ""  else    do      c = s.readLine    loop until (c > "") or s.EOF    return c  end ifEnd FunctionprimerWindow.openPrimerFile:Sub openPrimerFile(f as FolderItem)    dim stream as TextInputStream  dim irow, icol, iField, iLine, i as integer  dim line, field, cliptext as string    stream=f.OpenAsTextFile  line = nextline(stream)  field = NthField(line, chr(9), 1)    icol = 1  irow = 0  plist.cell(irow, icol) = field  iField = 2  iLine = 1  while (line > "") and (icol < plist.columnCount -1)    field = NthField(line, chr(9),iField)    while  (icol < plist.columnCount-1) // (field > "") and      icol = icol + 1      plist.cell(irow, icol) = field      ifield = ifield + 1      field = NthField(line, chr(9), ifield)    wend    line = nextLine(stream)    if line > "" then      icol = 0 // will be incremented      iField = 1      if irow > plist.listcount -2 then        plist.addrow ""      end if      irow = irow + 1    end if  wend  stream.Close  for i = plist.listcount-1 DownTo irow+1 // get rid of extra rows    plist.RemoveRow i  next    End SubprimerWindow.savePrimers:Sub savePrimers(f As folderitem)  dim stream as TextOutputStream  dim i, j as integer  dim line as string  if document <> nil then     stream = f.createTextFile    for i = 0 to plist.listcount-1       line = ""      for j = 1 to plist.columnCount-1         line = line + plist.cell(i,j)+ chr(9)      next      stream.writeLine line    next  end if  End SubprimerWindow.Tm:Function Tm(p As primer) As double  End FunctionprimerWindow.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  Super.Window()    if useWindowPosPrefs then    primerpoz.setvals self  end if    MsgBox "constructor is almost done except for self.show"    self.show    MsgBox "constructor is done"  End SubprimerWindow.readPrimerString:Protected Sub readPrimerString(dataString As string)  dim i, j, nr, nc, nl As integer  dim line, field As string  nr = CountFields(dataString, EndOfLine)  nc = plist.ColumnCount-1  for i = 0 to nr    line = NthField(dataString, EndOfLine, i+1)    if i > plist.ListCount-1 then plist.AddRow ""    for j = 1 to nc      field = NthField(line,chr(9), j)      plist.Cell(i,j) = field    next j  next i  nl = plist.ListCount -1  if nr < nl then    for i = nl DownTo nr+1      plist.RemoveRow(i)    next  end ifEnd SubprimerWindow.makePrimerString:Protected Function makePrimerString() As string  dim s As string  dim i, j, nr, nc As integer  nr = plist.ListCount-1  nc = plist.ColumnCount-1  for i = 0 to nr    if i <> 0 then s = s + EndOfLine    for j = 1 to nc      if j <> 1 then s = s + chr(9)      s = s + plist.Cell(i,j)    next j  next i  return sEnd FunctionprimerWindow.Activate:Sub Activate()  app.quitting = falseEnd SubprimerWindow.CancelClose:Function CancelClose(appQuitting as Boolean) As Boolean  if not app.quitting then    Self.Hide    return true  end ifEnd FunctionprimerWindow.Open:Sub Open()    foundRow = -1  // just so find Next menu item is disabled  hitclosebox = false    'MsgBox "okay, open event is done"  End SubprimerWindow.EnableMenuItems:Sub EnableMenuItems()  dim i as integer    'MsgBox "Starting to enable menus"  'MsgBox "Ubound(monofonts) is: " + str(UBound(monofonts))    fileSaveAs.Enable  fileSave.Enable  editClear.Enable  EditCopy.enable  EditPaste.enable  EditFind.enable    'MsgBox "got past EditFind.enable"    editFind.text = "Find ..."  EditInvertSelection.enable  if thePrimerfindWindow.searchString > "" then    EditFindNext.enable  end if  formatFont.Enable        for i = 0 to ubound(monofonts)    'MsgBox "Monofont number " + str(i) + " is " + fontz(i).text        fontz(i).Enable    fontz(i).Checked = fontz(i).text = plist.TextFont  next  formatSize.Enable  s9.Enable  s9.Checked = plist.TextSize = 9  s10.Enable  s10.Checked = plist.TextSize = 10  s12.Enable  s12.Checked = plist.TextSize = 12  s14.Enable  s14.Checked = plist.TextSize = 14  s18.Enable  s18.Checked = plist.TextSize = 18  s24.enable  s24.Checked = plist.TextSize = 24  formatPlain.Enable  formatPlain.Checked = not (plist.Bold or plist.Italic or plist.Underline)  formatBold.Enable  formatBold.Checked = plist.Bold  formatUnderline.Enable  formatUnderline.Checked = plist.Underline  formatItalic.Enable  formatItalic.Checked = plist.Italic    'MsgBox "menu enabling seemed to go okay"  End SubprimerWindow.plist.CompareRows:Function CompareRows(row1 as Integer, row2 as Integer, column as Integer, ByRef result as Integer) As Boolean  dim x1, x2 as integer  if column = 0 then    if plist.CellCheck(row1,0) then      x1 = 1    else       x1 = 0    end if    if plist.CellCheck(row2,0) then      x2=1    else      x2 = 0    end if    result = x2-x1    return true  end ifEnd FunctionprimerWindow.plist.CellGotFocus:Sub CellGotFocus(row as Integer, column as Integer)  focusrow = row  focuscolumn=columnEnd SubprimerWindow.plist.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nextrow, nextcol as integer    if key = chr(9) then  // user hit tab key    if column = me.columnCount-1 then      nextcol = 1      nextrow = row + 1      if row = me.listCount-1 then         me.addrow ""      end if    else      nextcol = column + 1      nextrow = row    end if        me.Editcell(nextrow, nextcol)    return true  end if  End FunctionprimerWindow.plist.Open:Sub Open()  'MsgBox "starting to open plist"    me.ColumnType(0) = 2  me.ColumnType(1) = 3  me.ColumnType(2) = 3  me.ColumnType(3) = 3  'MsgBox "done opening plist"  End SubprimerWindow.uncheckButton.Action:Sub Action()  dim i as integer  for i = 0 to plist.ListCount-1    plist.CellCheck(i,0) = not plist.CellCheck(i,0)  nextEnd SubprimerWindow.primerInfoButton.Action:Sub Action()  dim pr as primer  dim i as integer  dim s as string  dim olap As integer  dim quality As double  dim d As dimer  i = -1  do    i = i +1  loop until (plist.listIndex = i) or ( i > plist.ListCount)  if i > plist.ListCount then    msgBox ("No primer selected")  else    pr = new primer    pr.seq = pr.getseq(plist.Cell(i,1))    pr.name = plist.Cell(i,2)    pr.showInfo        checkDimer(pr, pr, olap, quality)    if quality >= dimerStringency and olap >= dimerOverlap then      d = new dimer      d.primer1 = pr      d.primer2 = pr      d.qual = quality      d.overlap = olap      putline d.report    end if  end ifEnd SubprimerWindow.PrimerTag.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim total, checked, selected, i as Integer  dim message as string  total = plist.ListCount  checked = 0  selected = 0  for i = 0 to plist.ListCount -1    if plist.CellCheck(i,0) then      checked = checked + 1    end if    if plist.Selected(i) then      selected = selected + 1    end if  next  message = str(total) + " primers in list;   "  message = message + str(checked) + " checked;   "  message = message + str(selected) + " rows selected"  me.text = messageEnd FunctionprimerWindow.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprimerWindow.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprimerWindow.Canvas1.Open:Sub Open()    'MsgBox "about to open canvas"    me.MouseCursor = finger    'MsgBox "opened canvas okay"  End SubprimerWindow.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display PrimerListHelpEnd FunctionprimerWindow.AddrowButton.Action:Sub Action()  plist.addrow ""  plist.ScrollPosition = plist.ListCount  plist.EditCell(plist.ListCount-1,1)End SubinfoWindow.AddInfo:Sub AddInfo(s as string)  dim line as string  line = "________________________________________________________________"  infoField.text = infoField.Text + s + EndOfLine + line + EndOfLine  infoField.Selstart = len(infoField.text)  infoField.SelLength = 0  me.ShowEnd SubinfoWindow.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  Super.Window()  if useWindowPosPrefs then    infopoz.setvals self  end ifEnd SubinfoWindow.putline:Sub putline(s As string)  infoField.text = infoField.text + EndOfLine + s  infofield.refreshEnd SubinfoWindow.Activate:Sub Activate()  app.quitting = falseEnd SubinfoWindow.CancelClose:Function CancelClose(appQuitting as Boolean) As Boolean  dim result as string  dim f as folderItem  dim stream as textoutputStream  if not app.quitting then    Self.Hide    return true  else    if Len(infoField.text) > 0 then      saveChanges.filename.text="Save changes to 'Results Wndow' before closing?"      saveChanges.ShowModal      result = saveChanges.buttonPressed      saveChanges.close      select case result      case "dontSave"        app.quitting = true        return false      case "cancel"        return true      case "save"        f = GetSaveFolderItem("text/Amplify", "")        if f <> Nil then // the user clicked Save          stream = f.createtextFile          stream.write infofield.text          stream.close          app.quitting = true          return false        else  // user clicked cancel          return true        end if        app.quitting = true      end select    end if    return false  end ifEnd FunctioninfoWindow.EnableMenuItems:Sub EnableMenuItems()  dim i as integer  fileSaveAs.Enable  selectAll.Enable  formatFont.Enable  EditFind.enable  editFind.text = "Find Text ..."  if searchString <> "" then editFindNext.Enable  for i = 0 to ubound (monofonts)    fontz(i).Enable    fontz(i).Checked = fontz(i).text = infoField.TextFont  next  EditInvertSelection.enable  formatSize.Enable  s9.Enable  s9.Checked = infoField.TextSize = 9  s10.Enable  s10.Checked = infoField.TextSize = 10  s12.Enable  s12.Checked = infoField.TextSize = 12  s14.Enable  s14.Checked = infoField.TextSize = 14  s18.Enable  s18.Checked = infoField.TextSize = 18  s24.enable  s24.Checked = infoField.TextSize = 24  formatPlain.Enable  formatPlain.Checked = not (infoField.Bold or infoField.italic or infoField.Underline)  formatBold.Enable  formatBold.Checked = infoField.Bold  formatUnderline.Enable  formatUnderline.Checked = infoField.Underline  formatItalic.Enable  formatItalic.Checked = infoField.ItalicEnd SubinfoWindow.infoField.Open:Sub Open()  dim f as string  if monofonts.indexOf (preferredFont) > -1 then    f = preferredFont  elseif monofonts.indexOf( "Monaco") > -1 then     f = "Monaco"  elseif monofonts.indexOf("QuickType Mono") > -1 then     f = "QuickType Mono"  elseif monofonts.indexOf("Courrier New") > -1 then    f = "Courrier New"  else     f = monofonts(0)  end if  me.TextFont = f  self.showEnd SubinfoWindow.PushButton1.Action:Sub Action()  // Just some speed trials. Can be deleted  dim bins(321) As integer  dim n() As variant  dim s, mem As string  dim bigs, smalls As string  dim r As new random  dim a,b As integer  dim i,j,trials, k , t, d, jm1 As integer  dim x,y As Double  dim dik As new Dictionary  dim m As match  trials = val(trialsb.text)  bigS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"  smalls = "Z"  a = ticks  for i = 1 to trials    'k = instr(bigs, smalls)    s = mid(bigs, k,2)  next  // Conclusion: InstrB is much faster than instr, but midB is not much better than mid, if at all  'for i = 1 to len(dbases)  'dik.value(mid(dbases,i,1))=i-1  'next  '    'j = val(elements.text)  '  'x = 3.14159  'd=1  'for i = 1 to trials  '//m = new match  '//m.tp = r.number * 10000  'n.append r.number * 10000  'next  'for i = 0 to trials-1  '//putline str(i) + "  :  " + str( (n(i)))  'next  'putline stringof(20,"-")  'a = Ticks  'ShellSort(n, 0, trials-1)  b = Ticks  'for i = trials-20 to trials-1  'putline str(i) + "  :  " + str(n(i))  'next  '  putline str(trials) + " trials took " + str((b-a)/60) + " with "+str(j) + " elements"  putline memEnd SubAmpWindow.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  dim i, n as integer  Super.Window()  n = 0  if useWindowPosPrefs then     for i = 0 to windowCount-1      if window(i) isa AmpWindow then n = n+1    next    if n > 1 then // offset multiple amp windows      amppoz.lft = amppoz.lft + 10      amppoz.tp = amppoz.tp + 10    end if    amppoz.setvals self  end ifEnd SubAmpWindow.Amplify:Sub Amplify()  dim i,j as integer  dim d As dimer  dim olap, longestp, n As integer  dim quality As Double  dim plist As listbox  dim p As primer  dim reply, numDimers As integer  dim dimerWarning As string  dim tstring,addon As string  dim GATCN As string = "GATCN"  dim fr As frag  dim Lb, Ub As integer  dim ms() As match  dim dw As DimerDialog    a = self  w = topSeqWindow  if w = nil then    msgBox "No target sequence is defined"    return  end if  plist = TheprimerWindow.plist  for i = 0 to plist.listCount -1    if plist.CellCheck(i,0) then      p = new primer      p.seq = p.getseq(plist.Cell(i,1))      p.name = plist.Cell(i,2)      primers.append p    end if  next   if ubound(primers) < 0 then    msgBox "No primers were used. Be sure to check the primers in the list that you want to use for this amplification"    self.close    return  end if  if not getTarg then    self.close    return  end if  for i = 0 to ubound(primers)    for j = i to ubound(primers)      checkDimer(primers(i), primers(j), olap, quality)      if quality >= dimerStringency and olap >= dimerOverlap then        d = new dimer        if len(primers(i).seq) <= len(primers(j).seq) then          d.primer1 = primers(i)          d.primer2 = primers(j)        else          d.primer1 = primers(j)          d.primer2 = primers(i)        end if        d.qual = quality        d.overlap = olap        dimers.Append d      end if    next j  next i  numDimers = ubound(dimers)  if  numDimers > -1 then         if numDimers = 0 then       dimerWarning = "A potential primer-dimer has been found. Do you want to see it?"    else      dimerWarning = "There are " + str(numDimers + 1) + " primer combinations with dimer-forming potential. Do you wnat to see them?"    end if    dw = new DimerDialog    dw.warning.text = dimerWarning    dw.ShowModal    if dw.yeshit then // answer is "Yes"      for i = 0 to numDimers        putline dimers(i).report      next      theinfoWindow.show    end if  end if    // Now, start finding matches  WaitYoass.message.text = "Generating PCR Map"  WaitYoass.remark.text = "checking primers ..."  WaitYoass.progress.value = 0  WaitYoass.show    linearLength = endTarget - startTarget + 1  tstring = Uppercase (mid(topSeqWindow.SeqT.text,startTarget+w.seqstart - 1, endTarget-starttarget +1))    if not linear then // add on an extra chunck to take care of overlapping matches    longestp = 0    for i = 0 to ubound(primers)      p = primers(i)      n = len(p.seq)      if n > longestp then longestp = n    next i    addon = Uppercase(mid(tstring, 1, longestp))    tstring = tstring + addon  end if // circular  'This addon will allow those overlapping matches to be caught. However, we should  'also take care of eliminating matches that are represented twice because of the  'redundancy in target. Also, the match report should extend the context to include  'the extra circular DNA    WaitYoass.Progress.Value = 10  WaitYoass.remark.Text = "looking for matches ..."  WaitYoass.Refresh    target = newMemoryBlock(len(tstring))  if target = nil then    msgBox "There is not enough memory available to continue with the amplification"    WaitYoass.Hide    return  end if  for i = 0 to target.size-1    target.byte(i) = instrB(GATCN, mid(tstring,i+1,1))-1  next  for i = 0 to ubound(primers)    primers(i).CalcZ    scanD(primers(i))    scanG(primers(i))    WaitYoass.Progress.Value = 10 + 60 * i/ubound(primers)    WaitYoass.Refresh  next    WaitYoass.remark.Text = "finding fragments ..."  WaitYoass.Refresh    'for i = 0 to ubound(matches)  'putline (matches(i).report)  'next  //putline tstring  if target <> nil then target = newMemoryBlock(1) // to free up memory        drawTarget  drawMatches   Lb = 0  Ub = ubound(matches)  ms = matches  sortMatches(ms, Lb, Ub)   for i = 0 to ubound(matches)-1    if matches(i).isD then      for j = i+1 to ubound(matches)        if not matches(j).isD then          fr = new frag          fr.ampWin = self          fr.Dmatch = matches(i)          fr.Gmatch = matches(j)          fr.linear = true          fr.findquality          frags.append fr        end if // not isD      next j    end if // isD        WaitYoass.Progress.Value = 70 + 30 * i/Ub    WaitYoass.Refresh  next i  if not linear then    for i = 1 to ubound(matches)      if matches(i).isD then        for j = 0 to i-1          if not matches(j).isD then            fr = new frag            fr.ampWin = self            fr.Dmatch = matches(i)            fr.Gmatch = matches(j)            fr.linear = false            fr.findquality            frags.append fr          end if // not isD        next j      end if // isD    next i  end if // not linear  WaitYoass.Progress.Value = 100  WaitYoass.Hide    sortFrags  drawFrags  w.amplifications.append selfEnd SubAmpWindow.getTarg:Protected Function getTarg() As boolean    if not w.formatted then w.doformat    DefineTarget.useSelection.value = false  DefineTarget.FirstBaseBox.text = "1"  DefineTarget.LastBaseBox.text = str(len(w.seqT.text)-w.seqstart+1)  DefineTarget.pickLinear.value = linearDefault  DefineTarget.pickCircular.value = not linearDefault  DefineTarget.a = a  DefineTarget.sw = w  DefineTarget.blurb.TextFont = afont  DefineTarget.blurb.text = "Amplify target sequence '" + w.title + "' using the " + str(Ubound(primers) + 1) + " selected primers."  DefineTarget.ShowModal  return DefineTarget.hit = 1End FunctionAmpWindow.Targ2text:Protected Function Targ2text(s As integer) As integer  dim t As integer  t = s + startTarget + w.seqStart -2  return tEnd FunctionAmpWindow.Text2Targ:Protected Function Text2Targ(t As integer) As integer  dim s As integer  s = t - startTarget - w.seqStart + 2  return sEnd FunctionAmpWindow.scanD:Sub scanD(p As primer)  dim tp As integer  dim primability, stability As Double  dim np, nt,i,j,k,baseval,thisRun,runCount As integer  dim m As match  dim seq As string  seq = right(p.seq, maxEffectivePrimer)  nt = target.size-1  np = len(seq)-1  tp = 0  for tp = 0 to nt    primability = 0    for i = 0 to min(np, tp)      primability = primability + p.z(i, target.byte(tp-i))      if primability < p.Req(i) then exit    next    if primability >= p.Req(np) then // looks good      // check stability      thisRun = 0      stability = 0      runCount = 0      for i = 0 to min(np,tp)        j = instrB(dbases, mid(seq,np-i+1,1))-1        k = target.byte(tp-i)        baseval = degeneratescores(j,k)        if baseval > 0 then          thisRun = thisRun + baseval          runCount = runCount + 1        else          stability = stability + thisRun * runWeights(max(0,runCount-1))          thisRun = 0          runCount = 0        end if      next i      stability = stability + thisRun * runWeights(max(0,runCount-1))      stability = 100 * stability /p.maxStab      if stability >= stabilityCutoff then        m = new match        m.primability = primability*100/p.maxPrimability        m.stability = stability        m.p = p        m.tp = tp        m.isD = true        m.startTarget = startTarget        matches.append m      end if    end if  next tpEnd SubAmpWindow.scanG:Sub scanG(p As primer)  dim tp As integer  dim primability, stability As Double  dim np, nt,i,j,k,baseval,thisRun,runCount As integer  dim m As match  dim seq As string  seq = right(p.seq, maxEffectivePrimer)  nt = target.size-1  np = len(seq)-1  tp = 0  for tp = 0 to nt    primability = 0    for i = 0 to min(np, nt-tp) // changed from scanD      primability = primability + p.zG(i, target.byte(tp+i)) // changed from scanD      if primability < p.Req(i) then exit    next    if primability >= p.Req(np) then // looks good      // check stability      thisRun = 0      stability = 0      runCount = 0      for i = 0 to min(np,nt-tp)  // changed from scanD        j = instrB(dcomp, mid(seq,np-i+1,1))-1  // changed from scanD        k = target.byte(tp+i)  // changed from scanD        baseval = degeneratescores(j,k)        if baseval > 0 then // this means that any nonzero value continues the run          thisRun = thisRun + baseval          runCount = runCount + 1        else          stability = stability + thisRun * runWeights(max(0,runCount-1))          thisRun = 0          runCount = 0        end if      next i      stability = stability + thisRun * runWeights(max(0,runCount-1))      stability = 100 * stability /p.maxStab      if stability >= stabilityCutoff then        m = new match        m.primability = primability*100/p.maxPrimability        m.stability = stability        m.p = p        m.tp = tp        m.isD = false        m.startTarget = startTarget        matches.append m      end if    end if  next tpEnd SubAmpWindow.DrawTarget:Protected Sub DrawTarget()    dim ss As stringShape  dim fs As curveShape  dim count, tickwidth, tickpos As integer  dim i, j As integer  dim mapColor As color  mapColor = &c46B1AF    ss = new stringShape  ss.TextFont = afont  ss.text = str(startTarget)  ss.x = ss.textSize * len(ss.text)/2  ss.x = max(ss.x, targX)  ss.y = ss.textSize + 5  d.append ss    ss = new stringShape  ss.TextFont = afont  ss.text = str(endTarget)  ss.x = mapX(endTarget)// - ss.textSize * len(ss.text)/2  ss.y = ss.textSize + 5  ss.FillColor = RGB(0,0,0)  d.append ss        fs = new curveShape  fs.x = targX  fs.y = targY  fs.x2 = targX  fs.y2 = ss.y + 2  fs.borderWidth = 1  fs.borderColor = mapColor  d.append fs    fs = new curveShape  fs.x = targX + targLen  fs.y = targY  fs.x2 = targX + targLen  fs.y2 = ss.y + 2  fs.borderWidth = 1  fs.borderColor = mapColor  d.append fs    tickwidth = 100  if endTarget - startTarget > 3000 then tickwidth = 500  if endTarget - startTarget > 10000 then tickwidth = 1000  tickpos = tickwidth  while tickpos < endTarget     if tickpos > startTarget then      fs=new curveShape      fs.borderColor = mapColor      fs.X = mapX(tickpos)      fs.Y = targY +6      fs.X2 = fs.X      fs.Y2 = targY - 7      d.append fs    end if    tickpos = tickpos + tickWidth  wend    fs = new curveShape  fs.x= targX  fs.y = targY  fs.x2= targX + targLen  fs.y2 = targY  fs.border = 100  fs.borderColor = RGB(0,0,0) // black  fs.borderWidth = 4  d.append fs  ss = new stringShape  ss.textFont = afont  ss.text = w.title  ss.textSize = ss.textSize + 4  ss.bold = true  ss.x = map.width/2  ss.y = ss.textSize  d.append ss    count = d.count  map.refreshEnd SubAmpWindow.mapX:Function mapX(targ As integer) As integer  return targX + targLen * (targ - startTarget)/(endTarget - startTarget)End FunctionAmpWindow.setMode:Protected Sub setMode(m As integer)  select case m  case 0    map.mouseCursor = arrowCursor    grabberbutton.icon = grabber1    magnifyButton.icon = plusicon  case 1    map.mouseCursor  =  grabber    grabberButton.icon = grabbedinv    magnifyButton.icon = plusIcon  case 2    grabberButton.icon = grabber1    map.mouseCursor = plus    magnifyButton.icon = plusinv  end select  mode = mEnd SubAmpWindow.drawMatches:Protected Sub drawMatches()  const pi = 3.14159  dim i As integer  dim s As stringShape  dim m As match  for i = 0 to ubound(matches)    s = new stringShape    s.TextFont = afont    m = matches(i)    m.AmpWin = self    m.drawme    s.text = left(m.p.name,7)    s.textsize = 10    s.rotation = Pi / 2    if m.isD then      m.y = targY - 14      s.y = m.y  - 10 -swidth(s)/2    else      m.y = targY + 13      s.y = m.y + 10 + swidth(s)/2    end if    m.x = mapX(m.tp + starttarget)    s.x = m.x - s.textsize/2    d.append m    d.append s  next  map.refreshEnd SubAmpWindow.SortMatches:Protected Sub SortMatches(byRef A() As match, byVal Lb As integer, byVal Ub As integer)  //shell sort  // from http://oopweb.com/Algorithms/Documents/Sman/VolumeFrames.html?/Algorithms/Documents/Sman/Volume/ShellSort_files/s_shl.htm  Dim n As Integer  Dim h As Integer  Dim i As Integer  Dim j As Integer  Dim t As match  //sort array[lb..ub]    //compute largest increment  n = Ub - Lb + 1  h = 1  If (n < 14) Then    h = 1  Else    While h < n      h = 3 * h + 1    wend    h = h \ 3    h = h \ 3  End If    While h > 0    //sort by insertion in increments of h    For i = Lb + h To Ub      t = A(i)      For j = i - h Downto Lb Step h        If (match(A(j)).tp) <= match(t).tp Then Exit /////// change this line to reflect data type: compare A(j) to t        A(j + h) = A(j)      Next j      A(j + h) = t    Next i    h = h \ 3  wend  End SubAmpWindow.sortFrags:Protected Sub sortFrags()  //shell sort  // from http://oopweb.com/Algorithms/Documents/Sman/VolumeFrames.html?/Algorithms/Documents/Sman/Volume/ShellSort_files/s_shl.htm  Dim n As Integer  Dim h As Integer  Dim i As Integer  Dim j As Integer  dim Ub, Lb As integer  dim A() As frag  Dim t As frag  //sort array[lb..ub]  Ub = ubound(frags)  Lb = 0  A() = frags()  //compute largest increment  n = Ub - Lb + 1  h = 1  If (n < 14) Then    h = 1  Else    While h < n      h = 3 * h + 1    wend    h = h \ 3    h = h \ 3  End If    While h > 0    //sort by insertion in increments of h    For i = Lb + h To Ub      t = A(i)      For j = i - h Downto Lb Step h        If (A(j).quality) <= t.quality Then Exit /////// change this line to reflect data type: compare A(j) to t        A(j + h) = A(j)      Next j      A(j + h) = t    Next i    h = h \ 3  wend  End SubAmpWindow.swidth:Protected Function swidth(ss As stringShape) As integer  dim size, sw As integer  dim font As string  dim bold As boolean  size = map.graphics.textSize  font = map.graphics.textfont  bold = map.graphics.bold  map.graphics.textSize = ss.textSize  map.graphics.textFont = ss.textFont  map.graphics.bold = ss.bold  sw = map.graphics.stringWidth(ss.text)  map.graphics.textSize = size  map.graphics.textFont = font  map.graphics.bold = bold  return swEnd FunctionAmpWindow.drawFrags:Protected Sub drawFrags()  dim i, j As integer  dim f As frag  dim ss As StringShape  for i = 0 to ubound(frags)    f = frags(i)    f.drawme    f.y = targY + 70 + i * fragGap    f.y2 = f.y    d.append f    ss = new StringShape    ss.textSize = 10    ss.TextFont = afont    ss.text = str(f.totSize)    ss.y = f.y + f.BorderWidth/2 + ss.TextSize/2 + 6    ss.x = f.x + (f.x2-f.x)/2    if not f.linear then       f.circlines.y = f.y      d.Append f.circlines    end if    d.Append ss    mapHeight = ss.y + 20  next  self.refreshEnd SubAmpWindow.fixMapScrollbar:Protected Sub fixMapScrollbar()  dim b As ScrollBar  b = ScrollBarmap  b.Maximum = max(-map.Height + mapHeight * d.scale,0)  b.Minimum = 0  b.PageStep = map.Height - 20  b.LineStep = map.Height/20  b.value = -d.yEnd SubAmpWindow.savemap:Protected Sub savemap(f As folderItem)  dim p As Picture  dim i As integer  dim x As object2D  standardMap  p = NewPicture(targlen + 50, mapHeight, 0)  p.Objects.Append d  f.MacCreator = "Ampl"  f.SaveAsPicture (p)End SubAmpWindow.standardMap:Protected Sub standardMap()  dim oldScale As double  dim i As integer  oldScale = d.Scale  d.x = 0  d.y = 0  d.scale = 1  if oldscale > 1 then    for i = 0 to ubound(matches)      matches(i).redrawme    next  end if  map.refreshEnd SubAmpWindow.EnableMenuItems:Sub EnableMenuItems()  FileSaveAs.Enable  FilePrint.EnableEnd SubAmpWindow.Open:Sub Open()  AmpWindowNumber = AmpWindowNumber + 1  if AmpWindowNumber > 1 then    self.title = "Amplification " + str(AmpWindowNumber)  else    self.title = "Amplification"  end ifEnd SubAmpWindow.map.MouseMove:Sub MouseMove(X As Integer, Y As Integer)  dim i,j, k as integer  'dim oldborder, old As integer  dim padding As integer  'dim oDwidth, oDborder, oGwidth, ogBorder As integer  'dim oDcolor, oGcolor As color  'dim oldColor As color  dim m As match  dim f As frag  dim found As boolean  dim s As string  if mode = 2 then    if keyboard.optionKey then      map.mouseCursor = minus    else      map.mouseCursor = plus    end if  elseif mode = 0 then    if y < d.scale*(targY+30) + d.y then // mouse in match area      found = false      for i = 0 to ubound(matches)        m = matches(i)        k = m.trianglesize * d.scale        if x > m.x -k and x < m.x +k and y > m.y -2*k and y < m.y + 2*k then          m.saveOld          m.borderwidth = m.borderwidth + 2          m.border = 100          found = true          ma = m          if m.isD then            for j = 0 to ubound(frags)              f = frags(j)              if f.Dmatch = m then                f.saveOld                f.BorderWidth = f.BorderWidth + 4                f.Border = 100                f.BorderColor = &c321DA0              end if            next          else // G            for j = 0 to ubound(frags)              f = frags(j)              if f.Gmatch = m then                f.saveOld                f.BorderWidth = f.BorderWidth + 4                f.Border = 100                f.BorderColor = &c321DA0              end if            next          end if // D or G          exit        end if      next      if found then        map.refresh        s = "primer: """ + m.p.name + """ at "         if m.isD then          s = s + str(m.tp + m.startTarget - len(m.p.seq) +1) + "-" + str(m.tp + m.startTarget) + " rightward"        else          s = s + str(m.tp + m.startTarget) + "-" + str(m.tp + m.startTarget + len(m.p.seq)-1) + " leftward"        end if        itemInfo.text = s        m.restoreOld        if m.isD then          for j = 0 to ubound(frags)            f = frags(j)            if f.Dmatch = m then              f.restoreOld            end if          next        else // G          for j = 0 to ubound(frags)            f = frags(j)            if f.Gmatch = m then              f.restoreOld            end if          next        end if // D or G      elseif itemInfo.text > "" then        itemInfo.text = ""        map.refresh        ma = nil      end if //found    else // mouse in fragment area      ma = nil      found = false      padding = 6 * d.scale      for i = 0 to ubound(frags)        f = frags(i)        if x >= f.x and x <= f.x2 and y > f.y-padding and y < f.y + padding then          found = true          fra = f          f.saveOld          f.Dmatch.saveOld          f.Gmatch.saveOld          f.Dmatch.BorderWidth = f.Dmatch.BorderWidth + 3          f.Dmatch.Border = 100          f.Dmatch.BorderColor = &c321DA0          f.Gmatch.BorderWidth = f.Gmatch.BorderWidth + 3          f.Gmatch.Border = 100          f.Gmatch.BorderColor = &c321DA0          f.borderwidth = f.borderWidth + 4          f.border = 100          f.borderColor = &c321DA0          exit        end if // found      next i      if found then        map.refresh        s = "Primers: """ + f.Dmatch.p.name + """ & """ + f.Gmatch.p.name + """   size = "        s = s + str(len(f.Dmatch.p.seq)) + " + " + str(f.Ampsize) + " + " + str(len(f.Gmatch.p.seq))        s = s + " = " + str(f.totSize)        itemInfo.text = f.infostring        f.restoreOld        f.Dmatch.restoreOld        f.Gmatch.restoreOld      elseif iteminfo.text > "" then        itemInfo.text = ""        fra = nil        map.refresh      end if // found    end if //y  end if //modeEnd SubAmpWindow.map.MouseExit:Sub MouseExit()End SubAmpWindow.map.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim w, h As integer  dim factor As double  dim oldcolor As color  dim oldborderwidth As integer  dim i As integer  select case mode  case 0 // arrow    if ma <> nil then      ma.saveOld      ma.fillColor = RGB(0,0,0)      ma.borderwidth = ma.borderwidth + 4      map.refresh      ma.restoreOld      return true    elseif fra <> nil then      fra.saveOld      fra.borderWidth = fra.borderwidth + 4      map.refresh      fra.restoreOld      return true    end if  case 1 // grabber    dragfromX = x    dragfromY = y    me.mouseCursor = grabbed    return true  case 2 // magnify    w = map.width    h = map.height        if keyboard.optionKey then      factor = 1/1.5    else      factor = 1.5    end if    // These formulae translate the clicked point to the center of the window    d.x = map.width/2 - (x - d.x) * factor    d.y = map.height/2 - (y - d.y) * factor    d.scale = d.scale * factor    if d.scale >= 1 then      for i = 0 to ubound(matches)        matches(i).redrawme      next    end if    map.refresh  end selectEnd FunctionAmpWindow.map.MouseUp:Sub MouseUp(X As Integer, Y As Integer)  dim selstart, k, padding As integer  map.refresh  select case mode  case 0    if ma <> nil then      k = ma.trianglesize * d.scale      if x > ma.x -k and x < ma.x +k and y > ma.y -2*k and y < ma.y + 2*k then        putline ma.report        if w <> nil then          if ma.isD then            selStart = Targ2text(ma.tp) - len(ma.p.seq) + 1          else            selStart = Targ2text(ma.tp)          end if          w.seqT.selStart = selStart          w.seqT.selLength = len(ma.p.seq)          w.seqT.scrollPosition = w.seqT.lineNumatCharPos(selStart)          w.SequenceScroll.value = w.seqT.ScrollPosition        end if // w        theInfoWindow.infoField.scrollPosition = 100000 // scroll to the bottom        theInfoWindow.show      end if    elseif fra <> nil then      padding = 6 * d.scale      if x >= fra.x and x <= fra.x2 and y > fra.y-padding and y < fra.y + padding then        fra.saveOld        fra.borderColor = RGB(255,255,255)        map.refresh        fra.restoreOld        map.refresh        putline fra.report        theInfoWindow.infoField.scrollPosition = 100000 // scroll to the bottom        theInfoWindow.show      end if    end if  case 1    me.mouseCursor = grabber      end select  End SubAmpWindow.map.MouseDrag:Sub MouseDrag(X As Integer, Y As Integer)  if mode = 1 then    d.x = d.x + (x-dragfromx)    d.y = d.y + (y-dragfromy)    d.y = max(d.y, -mapHeight * d.Scale + me.Height)    d.y = min(d.y, 0)    dragfromx = x    dragfromy = y    self.refresh  end ifEnd SubAmpWindow.map.Open:Sub Open()  d=new Group2D  mode = 0End SubAmpWindow.map.Paint:Sub Paint(g As Graphics)  g.drawObject d  fixMapScrollbarEnd SubAmpWindow.grabberbutton.Action:Sub Action()  if mode <> 1 then    setmode(1)  else     setmode(0)  end ifEnd SubAmpWindow.magnifyButton.Action:Sub Action()  setmode(2)End SubAmpWindow.normalButton.Action:Sub Action()  standardMapEnd SubAmpWindow.ArrowButton.Action:Sub Action()  setmode(0)End SubAmpWindow.ScrollBarmap.Open:Sub Open()  fixMapScrollbarEnd SubAmpWindow.ScrollBarmap.ValueChanged:Sub ValueChanged()  d.y = -me.value  self.RefreshEnd SubAmpWindow.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubAmpWindow.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubAmpWindow.Canvas1.Open:Sub Open()  me.MouseCursor = fingerEnd SubAmpWindow.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display AmplificationMapHelpEnd Functionprimer.getseq:Function getseq(old As string) As string  dim i, n, bas as integer  dim s, c as string  n = len(old)  isDegenerate = false  old = Uppercase(old)  for i = 1 to n    c = mid(old, i, 1)    bas = instr(bases, c)    if bas > 0 then      s = s + c      if bas > 4 then        isDegenerate = true      end if    end if  next  return Uppercase(s)End Functionprimer.showInfo:Sub showInfo()  dim s, b as string  dim g, a, t, c, gc, at, deg, i, k as integer  dim dgnrcy, xdgnrcy As double    s = "Primer: " + name  s = s +EndOfLine + "length = " + str(len(seq))  s = s +EndOfLine+ "Sequence: " + seq    for i = 1 to len(seq)    b = mid(seq, i,1)    Select case b    case "G"      g = g + 1      gc = gc + 1    case "A"      a = a + 1      at = at + 1    case "T"      t = t + 1      at = at + 1    case "C"      c = c + 1      gc = gc + 1    else       deg = deg + 1    end select  next   s = s + EndOfLine + "AT: " + str(at) + "    GC: " + str(gc) + "    " + str(100.0 * at/len(seq)) + "% AT"  s = s + EndOfLine + "G: " + str(g) + "    A:" + str(a) + "    T: " + str(t) + "    C: " + str(c) + "     Degenerate: " + str(deg)    if isdegenerate then    dgnrcy = 1    for i = 1 to len(seq)      k = instr(degenerates, mid(seq, i, 1))      if k = 0 then        xdgnrcy = 1      elseif k < 7 then        xdgnrcy = 2      elseif k < 11 then        xdgnrcy = 3      else        xdgnrcy = 4      end if      dgnrcy = dgnrcy * xdgnrcy    next    s = s + EndOfLine + "Fold degeneracy = " + str(dgnrcy)  end if    s = s + EndOfLine + "Tm = " + format(Tm, "#.00")  theinfoWindow.addInfo s  End Subprimer.Tm:Function Tm() As double  dim i, x, y, ln as integer  dim t, entr, enth, logsalt, logdna As double    t = 0  entr = 108  enth = 0  ln = len(seq)  for i = 1 to ln - 1    x = instr("GATC", mid(seq, i,1))-1    y = instr("GATC", mid(seq, i+1,1))-1    if x < 0 then      x = 4    end if    if y < 0 then      y = 4    end if    entr= entr + entropy(y,x)    enth = enth + enthalpy(y,x)  next  entr = -entr * 0.1  enth = -enth * 0.1  logdna = 1.987 * log(dnaconc / 4e9)  logsalt = 16.6 * log(saltconc / 1000) / log(10)  return (enth * 1000) / (entr + logdna) - 273.15 + logsalt  End Functionprimer.CalcZ:Sub CalcZ()  dim i,j,k,n As integer  dim s As string // for testing  maxStab = 0  maxPrimability = 0  n = min(maxEffectivePrimer, len(seq))  for i = 0 to n-1    for j = 0 to 4      k = Instr(dbases, mid(seq, len(seq)-i,1))-1      z(i,j) = MatchWeights(i) * Degeneratescores(k,j)    next j    Ideal(i) = max(z(i,0), z(i,1), z(i,2), z(i,3),z(i,4))    MaxPrimability = MaxPrimability + Ideal(i)    maxStab = maxStab + Ideal(i)/MatchWeights(i)    zG(i,0) = z(i,3)    zG(i,1) = z(i,2)    zG(i,2) = z(i,1)    zG(i,3) = z(i,0)    zG(i,4) = z(i,4)  next i  maxStab = maxStab * RunWeights(n-1)  Req(0) = MaxPrimability* (PrimabilityCutoff/100 - 1) + Ideal(0)  for i = 1 to n-1    Req(i) = Req(i-1) + Ideal(i)  next  return    // for testing  putline seq  putline ""  for i = 0 to n-1    s = mid(seq,n-i,1) + " :  "    for j = 0 to 4      s = s + numstr(z(i,j), 5)    next    s = s + "  Ideal: " + str(ideal(i))    s = s + "   Req: " + str(Req(i))    putline s  next  putline stringof(100,"_")  theInfoWindow.showEnd SubprefsWindow.FillBoxes:Protected Sub FillBoxes()  dim i,j As integer  saltfield.Text = str(saltConc)  DNAfield.Text = str(DNAconc)  for i = 0 to 4    for j = 1 to 5      EntropyBox.Cell(i,j) = str(Entropy(i,j-1))      EnthalpyBox.Cell(i,j) = str(Enthalpy(i,j-1))    next  next    for i = 0 to ubound(degenerateScores,1)    for j = 0 to ubound(degenerateScores, 2)      degenMatchBox.Cell(i, j+1) = str(degenerateScores(i,j))    next  next    for i = 0 to ubound(matchWeights)    matchWeightsbox.Cell(i,1) = str(matchWeights(i))    runWeightsBox.Cell(i,1) = str(runWeights(i))  next    for i = 0 to ubound(dimerScores,1)    for j = 0 to ubound(dimerScores,2)      dimerparamBox.cell(i,j+1) = str(dimerScores(i,j))    next  next    stringencyslider.value = dimerStringency    EndHeaderBox.text = left(endHeader, len(endHeader) -1)  saveWindowPosCheckbox.value = useWindowPosPrefs  prefFontField.Text = PreferredFont  headerColorCanvas.graphics.ForeColor = headerColor  primabilityBox.text = str(primabilityCutoff)  stabilityBox.text = str(stabilityCutoff)  effectivePrimerBox.text = str(effectivePrimer)  loadPrimer.value = defaultPrimerFile <> ""  loadTarget.value = defaultTargetFile <> ""  primerFilePath.text = defaultPrimerFile  targetFilePath.text = defaultTargetFile  dimeroverlapBox.text = str(dimerOverlap)  RadioLinear.value = linearDefault  RadioCircular.Value = not linearDefault    DNAField.Alignment=2  saltField.Alignment=2    End SubprefsWindow.ReadBoxes:Sub ReadBoxes()  dim i,j As integer  saltConc = val(saltField.Text)  DNAConc = val(DNAField.Text)  for i = 0 to 4    for j = 1 to 5      Entropy(i,j-1) = val(EntropyBox.Cell(i,j))      Enthalpy(i,j-1) = val(EnthalpyBox.Cell(i,j))    next  next  for i = 0 to degenMatchBox.ListCount-1    for j = 1 to degenMatchBox.ColumnCount-1      degenerateScores(i, j-1) = val(degenMatchBox.Cell(i,j))    next  next    for i = 0 to dimerParamBox.ListCount-1    for j = 1 to dimerParamBox.ColumnCount-1      dimerScores(i, j-1) = val(dimerParamBox.Cell(i,j))    next  next    dimerStringency = stringencyslider.value  dimerOverlap = val(dimerOverlapBox.text)    for i = 0 to matchWeightsBox.ListCount -1    matchWeights(i) = val(matchWeightsBox.cell(i,1))    runWeights(i) = val(runWeightsBox.Cell(i,1))  next    endHeader = endHeaderBox.Text + EndOfLine  preferredFont = prefFontField.text  useWindowPosPrefs = saveWindowPosCheckbox.value  headerColor = headerColorcanvas.graphics.foreColor  primabilityCutoff = val(primabilityBox.text)  stabilityCutoff = val(stabilityBox.text)  effectivePrimer = val(effectivePrimerBox.text)  minOverlap = val(dimeroverlapBox.text)    primerpoz.getvals theprimerwindow  infopoz.getvals theinfoWindow    defaultPrimerFile = primerFilePath.text  defaultTargetFile = targetFilePath.text    linearDefault = RadioLinear.value    for i = windowCount - 1 downTo 0    if window(i) isa seqWindow then      seqpoz.getvals window(i)    end if  next    for i = windowCount - 1 downTo 0    if window(i) isa ampWindow then      amppoz.getvals window(i)    end if  next  End SubprefsWindow.makePrefString:Function makePrefString() As string  dim d as date  dim t as string  dim i, j as integer  t = "#saltconc" + chr(9) + str(saltconc)  t = t + EndOfLine + "#DNAconc" + chr(9) + str(DNAconc)  t = t + EndOfLine + "#Enthalpy" + chr(9)  for i = 0 to ubound(Enthalpy, 1)    for j = 0 to ubound(Enthalpy, 2)      t = t + str(Enthalpy(i,j)) + ", "    next  next  t = t + EndOfLine + "#Entropy" + chr(9)  for i = 0 to ubound(Entropy, 1)    for j = 0 to ubound(Entropy, 2)      t = t + str(Entropy(i,j)) + ", "    next  next  t = t + EndOfLine + "#degenerateScores" + chr(9)  for i = 0 to ubound(degenerateScores, 1)    for j = 0 to ubound(degenerateScores, 2)      t = t + str(degenerateScores(i,j)) + ", "    next  next  t = t + EndOfLine + "#matchWeights" + chr(9)  for i = 0 to ubound(matchWeights)    t = t + str(matchWeights(i)) + ","  next  t = t + EndOfLine + "#runWeights" + chr(9)  for i = 0 to ubound(runWeights)    t = t + str(runWeights(i)) + ","  next  t = t + EndOfLine + "#endHeader" + chr(9) + left(endHeader, len(endHeader) -1)    t = t + EndOfLine + "#useWindowPosPrefs" + chr(9)  if useWindowPosPrefs then     t = t + "true"  else     t = t + "false"  end if    t = t + EndOfLine + "#dimerScores" + chr(9)  for i = 0 to ubound(dimerScores, 1)    for j = 0 to ubound(dimerScores, 2)      t = t + str(dimerScores(i,j)) + ","    next  next  t = t + EndOfLine + "#dimerStringency" + chr(9) + str(dimerStringency)  t = t + EndOfLine + "#dimerOverlap" + chr(9) + str(dimerOverlap)  t = t + EndOfLine + "#primabilityCutoff" + chr(9) + str(primabilityCutoff)  t = t + EndOfLine + "#stabilityCutoff" + chr(9) + str(stabilityCutoff)  //t = t + EndOfLine + "#ATvalue" + chr(9) + str(ATvalue)  //t = t + EndOfLine + "#GCvalue" + chr(9) + str(GCvalue)  t = t + EndOfLine + "#effectivePrimer" + chr(9) + str(effectivePrimer)  t = t + EndOfLine + "#minOverlap" + chr(9) + str(minOverlap)    t = t + EndOfLine + "#preferredFont" + chr(9) + preferredFont  t = t + EndOfLine + "#headerColor" + chr(9) + str(headerColor.red) +","+ str(headerColor.green) +","+ str(headerColor.blue)    t = t + EndOfLine + "#primerpoz" + chr(9) + primerpoz.stringof  t = t + EndOfLine + "#seqpoz" + chr(9) + seqpoz.stringof  t = t + EndOfLine + "#infopoz" + chr(9) + infopoz.stringof  t = t + EndOfLine + "#amppoz" + chr(9) + amppoz.stringof  t = t + EndOfLine + "#defaultPrimerFile" + chr(9) + defaultPrimerFile  t = t + EndOfLine + "#defaultTargetFile" + chr(9) + defaultTargetFile    t = t + EndOfLine + "#linearDefault" + chr(9)  if linearDefault then     t = t + "true"  else     t = t + "false"  end if    d = new date  return t + EndOfLine + d.shortdate + "; " + d.longtimeEnd FunctionprefsWindow.acquireDefaults:Sub acquireDefaults()  dim t As string  dim f As folderItem  dim instream As TextInputStream    f = getFolderItem("Amplify Prefs.prf")  if f <> nil then    instream = f.OpenAsTextFile  end if  if instream <> nil then    t = instream.readAll    instream.close    readPrefString t  else    readPrefString factory  end ifEnd SubprefsWindow.readPrefString:Sub readPrefString(incoming As string)  dim n, line, i, j As integer  dim t, theline, thename, thevalue as string  t = incoming  do // get rid of blank lines    n = len(t)    t = ReplaceAll(t, chr(13)+chr(13), chr(13))  loop until len(t) = n  line = 0  do    line = line + 1    theline = nthField(t, chr(13), line)    if mid(theline, 1,1) = "#" then      thename = NthField(theline, chr(9), 1)      thevalue = NthField(theline, chr(9), 2)            'MsgBox """" + thename + """ has value """ + thevalue + """"            Select case thename      case "#saltconc"        saltconc = val(thevalue)      case "#DNAconc"        DNAconc = val(thevalue)      case "#Entropy"        for i = 0 to ubound(Entropy, 1)          for j = 0 to ubound(Entropy, 2)            Entropy(i,j) = val(NthField(thevalue, ",", i*(ubound(Entropy,2) + 1) + j + 1))          next        next      case "#Enthalpy"        for i = 0 to ubound(Enthalpy, 1)          for j = 0 to ubound(Enthalpy, 2)            Enthalpy(i,j) = val(NthField(thevalue, ",", i*(ubound(Enthalpy,2) + 1) + j + 1))          next        next      case "#degenerateScores"        for i = 0 to ubound(degenerateScores, 1)          for j = 0 to ubound(degenerateScores, 2)            degenerateScores(i,j) = val(NthField(thevalue, ",", i*(ubound(degenerateScores,2) + 1) + j + 1))          next        next      case "#dimerScores"        for i = 0 to ubound(dimerScores, 1)          for j = 0 to ubound(dimerScores, 2)            dimerScores(i,j) = val(NthField(thevalue, ",", i*(ubound(dimerScores,2) + 1) + j + 1))          next        next      case "#dimerStringency"        dimerStringency = val(thevalue)      case "#dimerOverlap"        dimerOverlap = val(thevalue)      case "#matchWeights"        for i = 0 to ubound(matchWeights)          matchWeights(i) = val(NthField(thevalue, ",", i + 1))        next      case "#runWeights"        for i = 0 to ubound(runWeights)          runWeights(i) = val(NthField(thevalue, ",", i + 1))        next      case "#endHeader"        endHeader = thevalue + chr(13)      case "#useWindowPosPrefs"        useWindowPosPrefs = thevalue = "true"      case "#preferredFont"        preferredFont = thevalue      case "#headerColor"        headerColor = rgb(val(NthField(thevalue, ",", 1)), val(NthField(thevalue, ",", 2)), val(NthField(thevalue, ",", 3)))      case "#primabilityCutoff"        primabilityCutoff = val(thevalue)      case "#stabilityCutoff"        stabilityCutoff = val(thevalue)      case "#effectivePrimer"        effectivePrimer = val(thevalue)      case "#primerpoz"        primerpoz.readstring thevalue      case "#seqpoz"        seqpoz.readstring thevalue      case "#infopoz"        infopoz.readstring thevalue      case "#amppoz"        amppoz.readstring thevalue      case "#defaultPrimerFile"        defaultPrimerFile = thevalue      case "#defaultTargetFile"        defaultTargetFile = thevalue      case "#minOverlap"        minOverlap = val(thevalue)      case "#linearDefault"        linearDefault = thevalue = "true"      end Select    end if  loop until theline = ""  End SubprefsWindow.Open:Sub Open()  tempprefs = makePrefString  self.Left = (Screen(0).Width - self.Width) / 2  self.Top = (Screen(0).Height - self.Height) / 2End SubprefsWindow.prefsTabPanel.Open:Sub Open()  dim i, j as integer  for i = 1 to 5     EntropyBox.ColumnType(i) = 3    EnthalpyBox.ColumnType(i) = 3  next  for j = 0 to 4    EntropyBox.CellBold(j,0) = true    EntropyBox.CellBorderRight(j,0) = 5    EnthalpyBox.CellBorderRight(j,0) = 5    EnthalpyBox.CellBold(j,0) = true  next  EntropyBox.CellAlignment(3,3) = 3  Entropybox.ColumnAlignment(3) = 2  DNAField.Alignment = 2  SaltField.Alignment = 1    fillBoxesEnd SubprefsWindow.OKbutton.Action:Sub Action()  readBoxes  Self.CloseEnd SubprefsWindow.cancelButton.Action:Sub Action()  readPrefString tempPrefs  self.closeEnd SubprefsWindow.SaveButton.Action:Sub Action()  dim f as folderitem  dim ty As string  dim stream as TextOutputStream  readBoxes  f = getFolderItem("Amplify Prefs.prf")    if f <> nil then    ty = f.Type    stream = f.createTextFile    stream.Write makePrefString    stream.close  end if  self.closeEnd SubprefsWindow.restoreButton.Action:Sub Action()  acquireDefaults  fillBoxes  self.RefreshEnd SubprefsWindow.FactoryButton.Action:Sub Action()  readPrefString factory  fillBoxes  self.RefreshEnd SubprefsWindow.EntropyBox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.EntropyBox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.EntropyBox.SortColumn:Function SortColumn(column As Integer) As Boolean  return trueEnd FunctionprefsWindow.EnthalpyBox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.EnthalpyBox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.EnthalpyBox.SortColumn:Function SortColumn(column As Integer) As Boolean  return trueEnd FunctionprefsWindow.degenMatchBox.SortColumn:Function SortColumn(column As Integer) As Boolean  return trueEnd FunctionprefsWindow.degenMatchBox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.degenMatchBox.Open:Sub Open()  dim i, j as integer  me.columnType(0) = 1  for i = 1 to me.ColumnCount-1    me.columnType(i) = 3  next  me.columnAlignment(0) = 2  for i = 0 to me.listcount-1    me.CellBold(i,0) = true    me.CellBorderRight(i,0) = 5  nextEnd SubprefsWindow.degenMatchBox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.HeaderColorCanvas.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim c As color  if SelectColor(c, "Color for sequence header") then    headerColorcanvas.graphics.foreColor = c    self.refresh  end ifEnd FunctionprefsWindow.HeaderColorCanvas.Paint:Sub Paint(g As Graphics)  me.Graphics.FillRect(1,1,me.Graphics.Width-2,me.Graphics.Height-2)End SubprefsWindow.matchWeightsbox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.matchWeightsbox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.matchWeightsbox.Open:Sub Open()  dim i As integer  me.columnType(0) = 1  me.columnType(1) = 3  me.columnAlignment(0) = 2  for i = 0 to me.listcount-1    me.Cell(i,0) = str(i+1)    me.CellBold(i,0) = true    me.CellBorderRight(i,0) = 5  nextEnd SubprefsWindow.runWeightsBox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.runWeightsBox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.runWeightsBox.Open:Sub Open()  dim i As integer  me.columnType(0) = 1  me.columnType(1) = 3  me.columnAlignment(0) = 2  for i = 0 to me.listcount-1    me.Cell(i,0) = str(i+1)    me.CellBold(i,0) = true    me.CellBorderRight(i,0) = 5  nextEnd SubprefsWindow.dimerParamBox.Open:Sub Open()  dim i As integer  for i = 0 to me.listCount-1    me.CellBold(i,0) = true    me.CellAlignment(i,0) = 3    me.cellBorderRight(i,0) = 5  next  me.ColumnType(0) = 1  for i = 1 to me.Columncount-1    me.ColumnType(i) = 3  nextEnd SubprefsWindow.dimerParamBox.SortColumn:Function SortColumn(column As Integer) As Boolean  return trueEnd FunctionprefsWindow.dimerParamBox.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.foreColor = RGB(206,206,206)    g.fillrect 0,0,50,50  end ifEnd FunctionprefsWindow.dimerParamBox.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nrow, ncol as Integer  if key = chr(9) then    nrow = row    ncol = column + 1    if ncol > me.ColumnCount-1 then      ncol = 1      nrow = nrow + 1      if nrow > me.Listcount -1 then        nrow = 0      end if    end if    me.EditCell nrow, ncol  end ifEnd FunctionprefsWindow.loadPrimer.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  return true // just so mouseup will respondEnd FunctionprefsWindow.loadPrimer.MouseUp:Function MouseUp(X As Integer, Y As Integer) As Boolean  dim f, g As folderItem  if not me.value then    f=GetOpenFolderItem("text") //displays open-file dialog    if f <> nil then // something was opened      g = GetFolderItem("")      primerFilePath.text = f.AbsolutePath      me.value = true    end if  else    primerFilePath.text = ""    me.value = false  end ifEnd FunctionprefsWindow.loadTarget.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  return true // just so mouseup will respondEnd FunctionprefsWindow.loadTarget.MouseUp:Function MouseUp(X As Integer, Y As Integer) As Boolean  dim f As folderItem  if not me.value then    f=GetOpenFolderItem("text") //displays open-file dialog    if f <> nil then // something was opened      targetFilePath.text = f.absolutePath      me.value = true    end if  else    targetFilePath.text = ""    me.value = false  end ifEnd FunctionprefsWindow.RadioLinear.Action:Sub Action()  if me.value then RadioCircular.value = falseEnd SubprefsWindow.RadioCircular.Action:Sub Action()  if me.value then RadioLinear.value = falseEnd SubprefsWindow.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas1.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display PreferencesHelpEnd FunctionprefsWindow.Canvas2.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas2.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas2.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas2.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display GeneralPrefsHelpEnd FunctionprefsWindow.Canvas3.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas3.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas3.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas3.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display PCRSettingsHelpEnd FunctionprefsWindow.Canvas4.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas4.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas4.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas4.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display MatchSettingsEnd FunctionprefsWindow.Canvas5.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas5.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas5.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas5.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display TmHelpEnd FunctionprefsWindow.Canvas6.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubprefsWindow.Canvas6.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubprefsWindow.Canvas6.Open:Sub Open()  me.MouseCursor = fingerEnd SubprefsWindow.Canvas6.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display DimerCalcPrefsHelpEnd FunctionDefineTarget.UseSelection.Action:Sub Action()  if me.value then    s1 = firstBaseBox.text    s2 = lastBaseBox.text    firstBaseBox.text = str(sw.seqT.SelStart-sw.seqstart+2)    lastBaseBox.text = str(sw.seqT.SelStart-sw.seqstart+sw.seqT.SelLength+1)  else    firstBaseBox.text = s1    lastBaseBox.text = s2  end ifEnd SubDefineTarget.CancelButton.Action:Sub Action()  hit = 0  self.hideEnd SubDefineTarget.OkayButton.Action:Sub Action()  if a <> nil then    a.endTarget = val(lastBaseBox.text)    a.startTarget = val(firstBaseBox.text)    a.linear = pickLinear.value  end if  hit = 1  self.hideEnd SubDefineTarget.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubDefineTarget.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubDefineTarget.Canvas1.Open:Sub Open()  me.MouseCursor = fingerEnd SubDefineTarget.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display DefineTargetHelpEnd Functiondimer.report:Function report() As string  // primer1 should be shorter  dim t, a,b,c As string  dim b1,b2 As string  dim i, n1, n2, blank As integer  dim index1, index2 As integer  dim q  As double  n1 = len(primer1.seq)  n2 = len(primer2.seq)  t="Potential Primer Dimer:" +"     Quality = " + str(qual) + ",  Overlap = " + str(overlap) + EndOfLine  t = t + EndOfLine  a= "5' "  a = a+ stringof(overlap - n1) + primer1.seq  a = a + " 3'  " + primer1.name + EndOfLine  b= stringof(n1-overlap)+"3' "  for i = 1 to n2    b = b + mid(primer2.seq, n2-i+1,1)  next  b = b + " 5'  " + primer2.name + EndOfLine  blank =max(overlap-n1, n1-overlap) + 3  c=stringof(blank)  for i = blank+1 to blank + min(n1,overlap)    b1 = mid(a, len(c)+1,1)    b2 = mid(b,len(c)+1,1)    index1 = instrB(dbases, b1)-1    index2 = instrB(dbases, b2)-1    q = dimerScores(index1,index2)    if q < 0 then      c = c + " "    elseif q < 10 then      c = c + ":"    else      c = c + "|"    end if  next  t = t + a + c + EndOfLine + b    t = t + stringof(70,"_") + EndOfLine  return tEnd FunctionMeiStuff.numstr:Function numstr(x As Double, len As Integer) As string  return Right("                              " + Str(x), len)End FunctionMeiStuff.numstr:Function numstr(x As Double, len As integer, fmat As string) As string  return Right("                                       "+format (x, fmat), len)End FunctionMeiStuff.stringof:Function stringof(n As integer, s As string) As string  dim ss As string  dim i As integer  for i = 1 to n    ss = ss + s  next  return ssEnd FunctionMeiStuff.stringof:Function stringof(n As integer) As string  dim ss As string  dim i As integer  for i = 1 to n    ss = ss + " "  next  return ssEnd FunctionMeiStuff.min:Function min(x As double, y As double, z As double) As double  return min(min(x,y), z)End FunctionMeiStuff.max:Function max(x As double, y As double, z As double) As double  return  max(max(x,y),z)End FunctionMeiStuff.min:Function min(w As double, x As double, y As double, z As double) As double  return min(min(w,x,y),z)End FunctionMeiStuff.max:Function max(w As double, x As double, y As double, z As double) As double  return max(max(w,x,y),z)End FunctionMeiStuff.max:Function max(v As Double, w As double, x As double, y As double, z As double) As double  return max(Max(v,w,x,y), z)End FunctionMeiStuff.min:Function min(v As Double, w As double, x As double, y As double, z As double) As double  return min(min(v,w,x,y), z)End FunctionMeiStuff.shellSort:Sub shellSort(byRef A() As variant, byVal Lb As integer, byVal Ub As integer)  //shell sort  // from http://oopweb.com/Algorithms/Documents/Sman/VolumeFrames.html?/Algorithms/Documents/Sman/Volume/ShellSort_files/s_shl.htm  Dim n As Integer  Dim h As Integer  Dim i As Integer  Dim j As Integer  Dim t As variant  //sort array[lb..ub]    //compute largest increment  n = Ub - Lb + 1  h = 1  If (n < 14) Then    h = 1  Else    While h < n      h = 3 * h + 1    wend    h = h \ 3    h = h \ 3  End If    While h > 0    //sort by insertion in increments of h    For i = Lb + h To Ub      t = A(i)      For j = i - h Downto Lb Step h        If (A(j)) <= (t) Then Exit /////// change this line to reflect data type: compare A(j) to t        A(j + h) = A(j)      Next j      A(j + h) = t    Next i    h = h \ 3  wend  End SubMeiStuff.InsertionSort:Sub InsertionSort(byRef A() As variant, Lb As integer, Ub As Integer)    ' insert sort  // from http://oopweb.com/Algorithms/Documents/Sman/VolumeFrames.html?/Algorithms/Documents/Sman/Volume/ShellSort_files/s_shl.htm  // Has the advantage that like values stay in their original order. (i.e. "stable")  // but not as fast as Shell or Quicksort  Dim t As Variant  Dim i As Integer  Dim j As Integer    ' sort A[Lb..Ub]  For i = Lb + 1 To Ub    t = A(i)        ' shift elements down until insertion point found    For j = i - 1 Downto Lb Step 1      If A(j) <= t Then Exit ///////// adjust this line to compare A(j) and t by whatever method      A(j + 1) = A(j)    Next j        ' insert    A(j + 1) = t  Next i  End SubWaitYoass.Constructor:Sub Constructor()  // call the Window constructor, or Open events will not fire  Super.Window()  self.left=(screen(0).width - self.width)/2End Subfrag.report:Function report() As string  dim s, t As string  dim rightPart, leftPart As string  dim Astart, Aend As integer  dim w As seqWindow  Astart =Dmatch.tp+1 + Gmatch.startTarget  Aend = Gmatch.tp-1 + Gmatch.startTarget  s = stringof(50,"_") + EndOfLine  s = s + "Fragment Length = " + str(Ampsize + len(Dmatch.p.seq) + len(Gmatch.p.seq))   if not linear then s = s + "   (circular)"  s = s + EndOfLine + "Quality = " + str(quality) + EndOfLine  s = s + """" + Dmatch.p.name + """ >>["+ str(Astart) + " - " + str(Aend)+  "]<< """ + Gmatch.p.name + """"  ' Find the sequence of the amplicon  w = ampWin.w  if w = nil then    t ="Sequence unavailable. Target sequence window must remain open to access sequence data."  else    t = Dmatch.p.seq    if linear then      t = t + mid(w.SeqT.text, w.seqStart + Astart-1, Aend - Astart + 1)      w.SeqT.selStart = w.seqStart + Astart - len(Dmatch.p.seq) -2      w.SeqT.SelLength = totSize      w.seqT.scrollPosition = w.seqT.lineNumatCharPos(w.seqT.selStart)      w.SequenceScroll.value = w.seqT.ScrollPosition    else // circular      rightPart = mid(w.SeqT.text, w.seqStart + Astart-1, w.seqStart + ampWin.endTarget - Astart + 1)       leftPart = mid(w.SeqT.text, w.seqStart + ampWin.startTarget -1, Aend)      t = t + rightPart + antipar(leftPart)    end if    t = t + antipar(Gmatch.p.seq)  end if  s = s + EndOfLine + "Amplified sequence:" + EndOfLine  s = s + t + EndOfLine   return sEnd Functionfrag.findquality:Sub findquality()  if Dmatch <> nil and Gmatch <> nil then    if linear then      ampSize = Gmatch.tp - Dmatch.tp -1    else      ampSize = (ampWin.endTarget - Dmatch.tp) + (Gmatch.tp - ampWin.startTarget)    end if    totSize = len(Dmatch.p.seq) + Ampsize + len(Gmatch.p.seq)    quality = Dmatch.quality * Gmatch.quality    if quality > 0 then      quality = ampSize/quality^2    else      quality = 5000000000    end if  end ifEnd Subfrag.drawme:Sub drawme()  dim cutoffs() As integer  dim q As integer  dim i As integer  dim s As string  dim cs As CurveShape  dim arR, arL As FigureShape  cutoffs = array(100, 200, 300, 500, 700, 1000, 1500, 2000, 3000, 4000, 7000, 10000)  q = 0  for i = 0 to ubound(cutoffs)    if quality > cutoffs(i) then q = i  next  if q > 8 then    borderWidth = 1  else    borderWidth = 9-q  end if  border = 100  borderColor = RGB(0,0,0)  if q > 6 then borderColor = &c5B5B5B  if q > 8 then borderColor = &c8F8F8F  if q > 10 then borderColor = &cC1C1C1  if linear then    x = ampwin.mapX(Dmatch.tp + ampWin.startTarget)    x2 = ampwin.mapx(Gmatch.tp + ampWin.startTarget)    s = "Primers: """ + Dmatch.p.name + """ & """ + Gmatch.p.name + """   size = "    s = s + str(len(Dmatch.p.seq)) + " + " + str(Ampsize) + " + " + str(len(Gmatch.p.seq))    s = s + " = " + str(totSize)    infostring = s  else // circular    x = ampwin.mapX(ampWin.startTarget)    x2 = ampwin.mapX(ampWin.endTarget)    circlines = new group2D    cs = new CurveShape    cs.x = ampwin.mapX(Gmatch.tp + ampWin.startTarget)    cs.x2 = ampwin.mapX(Dmatch.tp + ampWin.startTarget)    cs.y = 0    cs.y2 = 0    cs.BorderWidth = BorderWidth + 4    cs.BorderColor = RGB(255,255,255)    circlines.Append cs    arR = new FigureShape    arR.AddLine (x2, -(BorderWidth +4), x2 + 5, 0)    arR.AddLine (x2 + 5, 0, x2, BorderWidth + 4)    arR.FillColor = RGB(0,0,0)    circlines.Append arR    arL = new FigureShape    arL.AddLine (x, -(BorderWidth +4), x - 5, 0)    arL.AddLine (x - 5, 0, x, BorderWidth + 4)    arL.FillColor = RGB(0,0,0)    circlines.Append arL    s = "Primers: """ + Dmatch.p.name + """ & """ + Gmatch.p.name + """ (circular)   size = "    s = s + str(len(Dmatch.p.seq)) + " + " + str(ampWin.endTarget - Dmatch.tp-1)+ " + " + str(Gmatch.tp-1 + Gmatch.startTarget) + " + " + str(len(Gmatch.p.seq))    s = s + " = " + str(totSize)    infostring = s  end ifEnd Subfrag.saveOld:Sub saveOld()  oldBorder = border  oldColor = BorderColor  oldwidth = borderWidthEnd Subfrag.restoreOld:Sub restoreOld()  border = oldBorder  BorderWidth = oldwidth  BorderColor = oldColorEnd SubMatch.report:Function report() As string  const leftC = 20  const rightC = 20  dim s,c,barz, Uc As string  dim Gseq, AntiSeq As string  dim w As seqWindow  dim leftActual as Integer  dim targpos1, textpos1 As integer  dim i, j, k, score As integer  w = ampWin.w  if w = nil then return "no target sequence"  if isD then    textpos1 = w.seqStart + startTarget + tp - len(p.seq)    targpos1 = startTarget + tp - len(p.seq)    leftActual = min(leftC, textpos1 - w.seqStart)    c = mid(w.seqT.text,textpos1 -leftActual, leftActual + len(p.seq) + rightC)    if textpos1-leftC < w.seqStart then      c = right(stringof(5*leftC, " ") + c ,leftC + len(p.seq) + rightC )  // pad the left end with spaces    end if    Uc = Uppercase(c)    s = stringof(80,"_") + EndOfLine +"Primer: '" + p.name + "'  (rightward)"    s = s+EndOfLine + "Primability = " + str(Primability) + "      Stability = " + str(Stability) + EndOfLine    s = s + EndOfLine + stringof(leftC-len(str(targpos1)) +1, " ") + str(targpos1+1)    s = s + stringof(len(p.seq)-3, " ") + str(targpos1 + len(p.seq))    s = s + EndOfLine + stringof(leftC," ") + "|" + stringof(len(p.seq)-2," ") + "|"    s = s+EndOfLine + stringof(leftC-3, " ") + "5' " + p.seq + " 3'"    barz = stringof(leftC," ")    for i = 1 to len(p.seq)      k = instrB(dbases, mid(p.seq, i,1))-1      j = instrB(dbases, mid(Uc, i + leftC,1)) -1      if j = -1 then        score = 0 // this means 5' end extends to the left of target      else        score = degenerateScores(k,j)      end if      if score = 0 then         barz = barz + " "      elseif score =100 then         barz = barz + "|"      else        barz = barz + ":"      end if    next    s = s + EndOfLine + barz + EndOfLine + c  else // is G    Gseq = ""    for i = 1 to len(p.seq)      Gseq = Gseq + mid(p.seq, len(p.seq) -i+1,1)    next    AntiSeq = antipar(p.seq)    textpos1 = w.seqStart + startTarget + tp + len(p.seq) //    targpos1 = startTarget + tp + len(p.seq) //    leftActual = min(leftC, textpos1 - w.seqStart-len(p.seq))    c = mid(w.seqT.text,textpos1 -leftActual-len(p.seq)-1, leftActual + len(p.seq) + rightC)    if textpos1-leftC-len(p.seq) < w.seqStart then      c = right(stringof(5*leftC, " ") + c ,leftC + len(p.seq) + rightC )  // pad the left end with spaces    end if    Uc = Uppercase(c)    s = stringof(80,"_") + EndOfLine +"Primer: '" + p.name + "'  (leftward)"    s = s+EndOfLine + "Primability = " + str(Primability) + "      Stability = " + str(Stability) + EndOfLine    barz = stringof(leftC," ")    for i = 1 to len(p.seq)      k = instrB(dbases, mid(AntiSeq, i,1))-1      j = instrB(dbases, mid(Uc, i + leftC,1)) -1      if j = -1 then        score = 0 // this means 5' end extends to the left of target      else        score = degenerateScores(k,j)      end if      if score = 0 then         barz = barz + " "      elseif score =100 then         barz = barz + "|"      else        barz = barz + ":"      end if    next    s = s + EndOfLine + c + EndOfLine + barz        s = s+EndOfLine + stringof(leftC-3, " ") + "3' " + Gseq + " 5'"    s = s + EndOfLine + stringof(leftC," ") + "|" + stringof(len(p.seq)-2," ") + "|"        s = s + EndOfLine + stringof(leftC-len(str(targpos1)) +1, " ") + str(targpos1-len(p.seq))    s = s + stringof(len(p.seq)-3, " ") + str(targpos1-1)          end if    return sException err as NilObjectException  return "Target sequence no longer defined"End FunctionMatch.drawme:Sub drawme()  dim q As integer  dim dcolors(), gcolors() as color  if not AmpWin.linear then tp = tp mod AmpWin.linearLength // in case primer is in overlap of circ DNA  dcolors = array(&c586CCB,&c5F6EB5,&cAFB9E6,&cD5DCFF, &cD5DCFF, RGB(255,255,255))  gcolors = array(&cBD3252,&cD35270,&cF0829B,&cFBABBE,&cFBABBE,RGB(255,255,255))  quality = (primability + stability - primabilityCutoff - stabilityCutoff)/(200-primabilityCutoff - stabilityCutoff)  q=0  if quality <.95 then q = 1  if quality < .8 then q = 2  if quality < .6 then q = 3  if quality < .4 then q = 4  if quality < .2 then q = 5  k = 5  if q > 0 then k = 4  if q > 2 then k = 3  me.border = 100  if not isD then    me.addline -k,0, k,2*k    me.addline k,2*k, k,-2*k    me.fillcolor = gcolors(q)  else    me.addline k,0, -k,2*k    me.addline -k,2*k, -k,-2*k    me.fillcolor = dcolors(q)  end if  borderwidth = 1  if q = 0 then me.borderwidth = 2  if q > 3 then border = 50  trianglesize = k + me.borderwidth  standardBorderWidth = me.BorderWidthEnd SubMatch.saveOld:Sub saveOld()  oldBorder = border  oldWidth = BorderWidth  oldFillColor = FillColor  oldBorderColor = BorderColor  oldx = x  oldy = yEnd SubMatch.restoreOld:Sub restoreOld()  border = oldBorder  BorderWidth = oldWidth  FillColor = oldFillColor  BorderColor = oldBorderColor  x = oldx  y = oldyEnd SubMatch.redrawme:Sub redrawme()  if isD then    item(0).x2 = item(0).x - 2*k    item(0).y2 = item(0).y + 2 * k    item(1).x = item(0).x2    item(1).y = item(0).y2    item(1).y2 = item(1).y - 4*k    item(1).x2 = item(1).x  else    item(0).x2 = item(0).x + 2*k    item(0).y2 = item(0).y + 2*k    item(1).x = item(0).x2    item(1).y = item(0).y2    item(1).y2 = item(1).y - 4 * k    item(1).x2 = item(1).x  end if  'BorderWidth = standardBorderWidth/AmpWin.d.ScaleEnd Subwindowpoz.stringof:Function stringof() As string  dim t as string  t = str(Lft) + "," + str(Tp) + "," + str(wdth) + "," + str(hght)  return tEnd Functionwindowpoz.readstring:Sub readstring(t As string)  Lft =val( NthField(t, ",", 1))  Tp = val( NthField(t, ",", 2))  Wdth = val( NthField(t, ",", 3))  Hght = val( NthField(t, ",", 4))End Subwindowpoz.getvals:Sub getvals(w As window)  lft = w.Left  tp = w.top  wdth = w.width  hght = w.heightEnd Subwindowpoz.setvals:Sub setvals(w As window)  w.top = tp  w.left = lft  w.width = wdth  w.height = hghtEnd SubwMenuItem.initialize:Sub initialize(wind As window)  w = wind  if wind = nil then    MsgBox "there is a nil window"  else    text = w.title  end if  AutoEnable = true  End SubwMenuItem.rebuild:Protected Sub rebuild()  dim m As MenuItem  dim wm As wMenuItem  dim wc, i, ub As integer  dim w As window  updateWindoze  wc = WindowMenu.count  for i = wc-1 DownTo 1    WindowMenu.item(i).close  next  aWindow(0).initialize theInfoWindow  wc = ubound(windoze)  for i = 1 to wc    w = windoze(i)    wm = new aWindow    wm.initialize w  nextEnd SubwMenuItem.EnableMenu:Sub EnableMenu()  if self.index <2 then self.rebuildEnd SubTargetFind.FindNext:Function FindNext(startPos As integer) As integer  // returns 0 if nothing found  dim i, j , pos, m As integer  dim t1, t2, t3 As integer    for i = startPos-1 to target.size-1-n    m = 0    for j = 0 to n-1      t1= sblock.byte(j)      t2 = target.byte(i+j)      t3 = sscores(sblock.byte(j), target.byte(i+j))      m = m + sscores(sblock.byte(j), target.byte(i+j))      if m > mm then exit    next j    if m > mm and both then      m = 0      for j = 0 to n-1        m = m + sscores(antiblock.byte(j), target.byte(i+j))        if m > mm then exit      next j    end if    if m <= mm then return i+1  next i  return 0End FunctionTargetFind.FindFirst:Function FindFirst() As integer  // returns 0 if nothing found  dim i, j As integer  dim GATCN As string  GATCN = "GATCN"  s = uppercase(searchStringBox.text)  anti = antipar(s)  n = len(s)  if len(anti) < n then anti = anti + stringof(n - len(anti), "N")  mm = val(MMAllowedBox.text)  both = bothDirections.value  target = newMemoryBlock(len(targ))  if target = nil then    msgBox "There is not enough memory available to continue with the amplification"    return 0  end if  for i = 0 to target.size-1    target.byte(i) = instrB(GATCN, mid(targ,i+1,1))  next  targ = ""  sblock = NewMemoryBlock(len(s))  antiblock = NewMemoryBlock(len(anti))  for i = 0 to sblock.size -1    sblock.byte(i) = instrB(dbases, mid(s, i+1, 1))  next  for i = 0 to antiblock.size -1    antiblock.byte(i) = instrB(dbases, mid(anti, i+1, 1))  next  for i = 0 to 15    for j = 0 to 5      if i * j = 0 then         sscores(i,j) = 1      else        if degenerateScores(i-1, j-1) = 0 then sscores(i,j) = 1      end if    next  next  return FindNext(1)End FunctionTargetFind.EnableMenuItems:Sub EnableMenuItems()  SelectAll.EnableEnd SubTargetFind.OkayButton.Action:Sub Action()  okay = true  self.HideEnd SubTargetFind.CancelButton.Action:Sub Action()  okay = false  self.hideEnd SubHelpWindow.display:Sub display(a As string)  dim s, t As string  s = NthField(a, delim, 2)  t = NthField(a, delim, 1)  field.SetTextAndStyle(t, s)End SubHelpWindow.Open:Sub Open()  field.ScrollPosition = 0End SubHelpWindow.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  closeEnd FunctionHelpWindow.PushButton1.Action:Sub Action()  self.closeEnd SubDimerDialog.Nobutton.Action:Sub Action()  yeshit = false  self.hideEnd SubDimerDialog.Yesbutton.Action:Sub Action()  yeshit = true  self.hideEnd SubDimerDialog.HelpButton1.Open:Sub Open()  me.MouseCursor = fingerEnd SubDimerDialog.HelpButton1.MouseExit:Sub MouseExit()  me.icon = qballaEnd SubDimerDialog.HelpButton1.MouseEnter:Sub MouseEnter()  me.icon = qballbEnd SubDimerDialog.HelpButton1.Action:Sub Action()  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display PrimerDimerHelpEnd SubLegalWindow.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  self.closeEnd FunctionLicenseWindow.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  me.closeEnd FunctionLicenseWindow.StaticText3.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  ShowURL me.textEnd FunctionLicenseWindow.StaticText3.Open:Sub Open()  me.MouseCursor= fingerEnd SubdataWindow.nextline:Function nextline(s as textInputStream) As string  dim c as string  c = ""  if s.EOF then     return ""  else    do      c = s.readLine    loop until (c > "") or s.EOF    return c  end ifEnd FunctiondataWindow.openPrimerFile:Sub openPrimerFile(f as FolderItem)    dim stream as TextInputStream  dim irow, icol, iField, iLine, i as integer  dim line, field, cliptext as string    stream=f.OpenAsTextFile  line = nextline(stream)  field = NthField(line, chr(9), 1)    icol = 1  irow = 0  plist.cell(irow, icol) = field  iField = 2  iLine = 1  while (line > "") and (icol < plist.columnCount -1)    field = NthField(line, chr(9),iField)    while  (icol < plist.columnCount-1) // (field > "") and      icol = icol + 1      plist.cell(irow, icol) = field      ifield = ifield + 1      field = NthField(line, chr(9), ifield)    wend    line = nextLine(stream)    if line > "" then      icol = 0 // will be incremented      iField = 1      if irow > plist.listcount -2 then        newRow      end if      irow = irow + 1    end if  wend  stream.Close  for i = plist.listcount-1 DownTo irow+1 // get rid of extra rows    plist.RemoveRow i  next    End SubdataWindow.savePrimers:Sub savePrimers(f As folderitem)  dim stream as TextOutputStream  dim i, j as integer  dim line as string  if document <> nil then     stream = f.createTextFile    stream.write makeDataString    stream.close  end if  End SubdataWindow.Constructor:Sub Constructor()  '// call the Window constructor, or Open events will not fire  'Super.Window()  'if DataPoz.hght > 0 then  'DataPoz.setvals self  'end ifEnd SubdataWindow.newRow:Protected Sub newRow()  plist.addrow str(plist.ListCount+1)  plist.cellBold(plist.ListCount-1, 0) = trueEnd SubdataWindow.NumberRows:Protected Sub NumberRows()  dim i As Integer  for i = 0 to plist.ListCount-1    plist.Cell(i,0) = str(i+1)  nextEnd SubdataWindow.makeDataString:Function makeDataString() As string  dim s As string  dim i, j, nr, nc As integer  nr = plist.ListCount-1  nc = plist.ColumnCount-1  for i = 0 to nr    if i <> 0 then s = s + EndOfLine    for j = 1 to nc      if j <> 1 then s = s + chr(9)      s = s + plist.Cell(i,j)    next j  next i  return sEnd FunctiondataWindow.readDataString:Sub readDataString(dataString As string)  dim i, j, nr, nc As integer  dim line, field As string  nr = CountFields(dataString, EndOfLine)-1  nc = plist.ColumnCount-1  for i = 0 to nr    line = NthField(dataString, EndOfLine, i+1)    if i > plist.ListCount-1 then newRow    for j = 1 to nc      field = NthField(line,chr(9), j)      plist.Cell(i,j) = field    next j  next iEnd SubdataWindow.Activate:Sub Activate()  app.quitting = falseEnd SubdataWindow.CancelClose:Function CancelClose(appQuitting as Boolean) As Boolean  if not app.quitting then    Self.Hide    return true  end ifEnd FunctiondataWindow.Open:Sub Open()    foundRow = -1  // just so find Next menu item is disabled  hitclosebox = falseEnd SubdataWindow.EnableMenuItems:Sub EnableMenuItems()  'dim i as integer  'fileSaveAs.Enable  'fileSave.Enabled = document <> nil  'editClear.Enable  'EditCopy.enable  'editCut.enable  'editSelectAll.enable  'EditPaste.enable  'EditFind.enable  'editFind.text = "Find ..."  'EditDeleteRows.enabled = rowSelectionEnd SubdataWindow.plist.CellClick:Function CellClick(row as Integer, column as Integer, x as Integer, y as Integer) As Boolean  rowSelection = column = 0  clickRow = row  clickCol = columnEnd FunctiondataWindow.plist.CellBackgroundPaint:Function CellBackgroundPaint(g As Graphics, row As Integer, column As Integer) As Boolean  if column = 0 then    g.ForeColor = RGB(240,240,240)    g.FillRect 0,0,g.width,g.height    return false  end ifEnd FunctiondataWindow.plist.CompareRows:Function CompareRows(row1 as Integer, row2 as Integer, column as Integer, ByRef result as Integer) As Boolean  dim x1, x2 as integer  if column = 0 then    if plist.CellCheck(row1,0) then      x1 = 1    else       x1 = 0    end if    if plist.CellCheck(row2,0) then      x2=1    else      x2 = 0    end if    result = x2-x1    return true  end ifEnd FunctiondataWindow.plist.CellGotFocus:Sub CellGotFocus(row as Integer, column as Integer)  focusrow = row  focuscolumn=columnEnd SubdataWindow.plist.CellKeyDown:Function CellKeyDown(row as Integer, column as Integer, key as String) As Boolean  dim nextrow, nextcol as integer    if key = chr(9) then  // user hit tab key    if column = me.columnCount-1 then      nextcol = 1      nextrow = row + 1      if row = me.listCount-1 then         newRow      end if    else      nextcol = column + 1      nextrow = row    end if        me.Editcell(nextrow, nextcol)    return true  end if  End FunctiondataWindow.plist.Open:Sub Open()  me.ColumnType(0) = plist.TypeNormal  me.ColumnType(1) = plist.TypeEditable  me.ColumnType(2) = plist.TypeEditable  me.ColumnAlignment(1) = plist.AlignRight  me.ColumnAlignment(2) = plist.AlignRight  me.ColumnAlignment(0) = plist.AlignRight  me.cellBold(0, 0) = true  me.ColumnSortDirection(0) = me.SortNone  me.ColumnSortDirection(1) = me.SortNone  me.ColumnSortDirection(2) = me.SortNone  'me.ColumnAlignmentOffset(1)=-me.column(1).WidthActual/3    clickRow = 0  clickCol = 1  rowSelection = trueEnd SubdataWindow.plist.Change:Sub Change()  if me.selCount = 0 then     rowSelection = true    clickRow = 0    clickCol = 1  end ifEnd SubdataWindow.PrimerTag.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim total, checked, selected, i as Integer  dim message as string  total = plist.ListCount  checked = 0  selected = 0  for i = 0 to plist.ListCount -1    if plist.CellCheck(i,0) then      checked = checked + 1    end if    if plist.Selected(i) then      selected = selected + 1    end if  next  message = str(total) + " primers in list;   "  message = message + str(checked) + " checked;   "  message = message + str(selected) + " rows selected"  me.text = messageEnd FunctiondataWindow.Canvas1.MouseExit:Sub MouseExit()  me.Backdrop = qballaEnd SubdataWindow.Canvas1.MouseEnter:Sub MouseEnter()  me.Backdrop = qballbEnd SubdataWindow.Canvas1.Open:Sub Open()  me.MouseCursor = fingerEnd SubdataWindow.Canvas1.MouseDown:Function MouseDown(X As Integer, Y As Integer) As Boolean  dim h As HelpWindow  h = new HelpWindow  h.top = (screen(0).height - h.height)/2  h.Left = (screen(0).width - h.width)/2  h.display PreferencesHelpEnd FunctiondataWindow.addRowButton.Action:Sub Action()  newRowEnd SubdataWindow.FormatButton.Action:Sub Action()  'dim w As formatWindow  'dim i, n As integer  'dim s As string  'n = plist.ListCount-1  'w = new formatWindow  'w.ShowModal  'if Xformat <> "" then  'for i = 0 to n  's = plist.Cell(i,1)  'if s <> "" then plist.Cell(i,1) = format(val(s), Xformat)  'next  'end if  'if Yformat <> "" then  'for i = 0 to n  's = plist.Cell(i,2)  'if s <> "" then plist.Cell(i,2) = format(val(s), Yformat)  'next  'end if  'self.RefreshEnd Sub